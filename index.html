<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>小狒sin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="小狒sin">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小狒sin">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sinker">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.3.0"></head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://tva4.sinaimg.cn/large/6f4890d4gy1gml6uophvsj20m60m6mz3.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/s1nker" title="github">github</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/sin-chaw" title="zhihu">zhihu</a>
					        
								<a class="douban" target="_blank" href="https://www.douban.com/people/56917679/" title="douban">douban</a>
					        
								<a class="mail" target="_blank" href="mailto:s1nker@126.com" title="mail">mail</a>
					        
								<a class="linkedin" target="_blank" href="https://cn.linkedin.com/in/s1nker" title="linkedin">linkedin</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Base64/" style="font-size: 10px;">Base64</a> <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/E2E-%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">E2E 测试</a> <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/FormData/" style="font-size: 10px;">FormData</a> <a href="/tags/Geoserver/" style="font-size: 10px;">Geoserver</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Nightmare/" style="font-size: 10px;">Nightmare</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/React-fiber/" style="font-size: 10px;">React fiber</a> <a href="/tags/React-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">React 源码学习</a> <a href="/tags/SLD/" style="font-size: 10px;">SLD</a> <a href="/tags/Safari/" style="font-size: 10px;">Safari</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/development-docs/" style="font-size: 10px;">development docs</a> <a href="/tags/feeling/" style="font-size: 10px;">feeling</a> <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/javascript/" style="font-size: 15px;">javascript</a> <a href="/tags/js%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">js对象</a> <a href="/tags/leaflet/" style="font-size: 10px;">leaflet</a> <a href="/tags/life/" style="font-size: 15px;">life</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/openlayers/" style="font-size: 10px;">openlayers</a> <a href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" style="font-size: 10px;">作用域</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">单元测试</a> <a href="/tags/%E5%9C%B0%E5%9B%BE/" style="font-size: 10px;">地图</a> <a href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" style="font-size: 10px;">深拷贝</a> <a href="/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/" style="font-size: 10px;">组件封装</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">自动化测试</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">热爱分享，乐于折腾的前端程序猿，脑洞有点大！</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://tva4.sinaimg.cn/large/6f4890d4gy1gml6uophvsj20m60m6mz3.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/s1nker" title="github">github</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/sin-chaw" title="zhihu">zhihu</a>
			        
						<a class="douban" target="_blank" href="https://www.douban.com/people/56917679/" title="douban">douban</a>
			        
						<a class="mail" target="_blank" href="mailto:s1nker@126.com" title="mail">mail</a>
			        
						<a class="linkedin" target="_blank" href="https://cn.linkedin.com/in/s1nker" title="linkedin">linkedin</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-fiber-learning" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/12/16/fiber-learning/" class="article-date">
  	<time datetime="2020-12-15T16:00:00.000Z" itemprop="datePublished">2020-12-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/16/fiber-learning/">React Fiber 浅析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="React-Fiber-浅析"><a href="#React-Fiber-浅析" class="headerlink" title="React Fiber 浅析"></a>React Fiber 浅析</h1><p><img src="https://tva2.sinaimg.cn/large/6f4890d4gy1gml763tfnhj20rs0igdgy.jpg" alt="react-fiber"></p>
<h2 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h2><p>我们知道从广义上来讲，浏览器是单线程的，它将 GUI 描绘，时间器处理，事件处理，js 执行，远程资源加载统统放在一起。在 React 15 及之前的版本，React 在对组件进行更新时，如果需要渲染更新的组件过于庞大，js 执行就会长时间占据主线程，导致页面的响应变慢。当然 React 也提供了优化的手段（<code>shouldComponentUpdate</code>），但是这种优化方式更多是依赖于使用者自身，这种单纯的人肉优化并没有很好地改善这种情况。</p>
<h2 id="2-一些前置概念"><a href="#2-一些前置概念" class="headerlink" title="2. 一些前置概念"></a>2. 一些前置概念</h2><h3 id="2-1-Renderers（渲染器）和-Reconcilers（协调器）"><a href="#2-1-Renderers（渲染器）和-Reconcilers（协调器）" class="headerlink" title="2-1. Renderers（渲染器）和 Reconcilers（协调器）"></a>2-1. Renderers（渲染器）和 Reconcilers（协调器）</h3><p>React 最开始服务于 DOM，后来又有了支持原生平台的 React Native，为了区分开这两者，React 内部提出了“**渲染器 (Renderers)**”的概念。</p>
<blockquote>
<p>渲染器用于管理一棵 React 树，使其根据底层平台进行不同的调用。</p>
</blockquote>
<p>即使 React DOM 和 React Native 渲染器区别很大，但也需要共享一些逻辑。特别是<strong>协调 (Reconciliation)</strong> 算法需要尽可能相似，这样可以让声明式渲染，自定义组件，state，生命周期方法和 refs 等特性，保持跨平台工作一致。</p>
<p>为了解决这个问题，不同的渲染器彼此共享一些代码。我们称 React 的这一部分为 “<strong>reconciler（协调器）</strong>”。当处理类似于 <code>setState()</code> 这样的更新时，reconciler 会调用树中组件上的 <code>render()</code>，然后决定是否进行挂载，更新或是卸载操作。</p>
<h3 id="2-2-Reconciliation-协调"><a href="#2-2-Reconciliation-协调" class="headerlink" title="2-2. Reconciliation 协调"></a>2-2. Reconciliation 协调</h3><p>React 是一个用于构建用户界面的 JavaScript 库，一个核心的机制是跟踪组件的状态变化，并将更新后的状态映射到新的界面。这个过程被称为 <strong>Reconciliation</strong>（协调）。我们调用 setState 方法来改变状态，而框架本身会去检查 state 或 props 是否已经更改来决定是否重新渲染组件。</p>
<p>在开始了解 Fiber 架构前，先简单看一下协调过程中的 “Diffing” 算法的设计决策：</p>
<blockquote>
<p>React 的 <code>render</code> 方法在组件 state 和 props 变更时计算返回新的树，React 需要基于这新旧两棵树之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步。</p>
</blockquote>
<blockquote>
<p>这个算法问题有一些通用的解决方案，即生成将一棵树转换成另一棵树的最小操作数。 然而，即使在最前沿的算法中，该算法的复杂程度为 O(n 3 )，其中 n 是树中元素的数量。</p>
</blockquote>
<p>（引用自<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/reconciliation.html">协调 - React</a>）</p>
<p>React 主要是基于以下的两个假设，对 “<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/reconciliation.html">Difffing</a>“ 算法进行了优化</p>
<ol>
<li>两个不同类型的元素会产生出不同的树；</li>
<li>开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定；</li>
</ol>
<h3 id="2-3-Fiber-架构的目标"><a href="#2-3-Fiber-架构的目标" class="headerlink" title="2-3. Fiber 架构的目标"></a>2-3. Fiber 架构的目标</h3><p>上文已经提到，React 15 及更早的版本在更新组件时，会持续占用主线程，这样主线程上的布局、动画等周期性任务以及交互响应就无法立即得到处理，导致掉帧。Stack reconciler 是指 React 15 及更早的 reconciler 解决方案，它其实是自顶向下的递归 mount/update，这种自顶向下递归的方法在节点较多的时候会需要很长的处理时间。</p>
<p><img src="https://tva4.sinaimg.cn/large/6f4890d4gy1gml76ovdbnj218g0r6dlf.jpg" alt="stack-reconciler"></p>
<p>于是就<a target="_blank" rel="noopener" href="https://github.com/acdlite/react-fiber-architecture">有人提出来</a>，如果仅依靠浏览器自己去调用堆栈，它将一直工作到堆栈为空为止……如果我们能够随意中断堆栈的调用并手动操作堆栈帧，那不是很好吗？通过设置固定的时间分片，在每个分片内灵活地处理堆栈的任务，并且进行一次页面的渲染，这样就可以保证页面的刷新频率。</p>
<p><img src="https://tva1.sinaimg.cn/large/6f4890d4gy1gmlu89aaeej20r80eyq7q.jpg" alt="fiber-reconciler"></p>
<p>但是除了需要对任务进行切片，还需要增加一个任务的优先级，因为对于用户体验来说，用户输入的响应事件要优先于请求填充内容，并且高优先级的任务可以打断低优先级的任务。</p>
<p>Fiber 架构的主要目标是（后两个其实属于附带的目标）：</p>
<ul>
<li>能够把可中断的任务切片处理。</li>
<li>能够调整优先级，重置并复用任务。</li>
<li>能够在父元素与子元素之间交错处理，以支持 React 中的布局。</li>
<li>能够在 <code>render()</code> 中返回多个元素。</li>
<li>更好地支持错误边界。</li>
</ul>
<h2 id="3-数据结构及算法"><a href="#3-数据结构及算法" class="headerlink" title="3. 数据结构及算法"></a>3. 数据结构及算法</h2><h3 id="3-1-从-React-元素到-Fiber-节点"><a href="#3-1-从-React-元素到-Fiber-节点" class="headerlink" title="3-1. 从 React 元素到 Fiber 节点"></a>3-1. 从 React 元素到 Fiber 节点</h3><p>在讲 Fiber 架构之前，我们先看一下 React 在 V15 及之前是怎么处理虚拟 DOM 以及实际节点的。在 React 运行的时候，会存在有以下三种实例：</p>
<blockquote>
<p>DOM - 真实的 DOM 节点<br>Instances - react 维护的虚拟 DOM 节点<br>Elements - 对 UI 进行描述 eg. type, props</p>
</blockquote>
<p>显然要做到上文提到的增量更新，按照这些实例是很难满足的，所以 React 在原有的基础上进行扩展：</p>
<blockquote>
<p>DOM - 真实的 DOM 节点<br>effect - 即副作用 (side effect)，包括 DOM change 等操作<br>workInProgress - workInProgress tree是reconcile过程中从fiber tree建立的当前进度快照，用于断点恢复<br>fiber - fiber tree与vDOM tree类似，用来描述增量更新所需的上下文信息<br>Elements - 对 UI 进行描述 eg. type, props</p>
</blockquote>
<p>fiber tree上各节点的主要结构（每个节点称为fiber）：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// fiber tree节点结构</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">state</span>Node,</span><br><span class="line">    child,</span><br><span class="line">    return,</span><br><span class="line">    sibling,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>return表示当前节点处理完毕后，应该向谁提交自己的成果（effect list），在这里 fiber tree 使用的是<strong>链表结构</strong>。</p>
<h3 id="3-2-Fiber-节点"><a href="#3-2-Fiber-节点" class="headerlink" title="3-2. Fiber 节点"></a>3-2. Fiber 节点</h3><p>在协调期间，从 render 方法返回的每个 React 元素的数据都会被合并到 Fiber 节点树中。每个 React 元素都有一个相应的 Fiber 节点。与 React 元素不同，不会在每次渲染时重新创建这些 Fiber 。这些是持有组件状态和 DOM 的可变数据结构。</p>
<p>根据不同 React 元素的类型，框架需要执行不同的活动。对于类组件，它调用生命周期方法和 render 方法，而对于 span 宿主组件（DOM 节点），它进行得是 DOM 修改。因此，每个 React 元素都会转换为 相应类型 的 Fiber 节点，用于描述需要完成的工作。</p>
<p>您可以将 Fiber 视为表示某些要做的工作的数据结构，或者说，是一个工作单位。Fiber 的架构还提供了一种跟踪、规划、暂停和销毁工作的便捷方式。</p>
<p>当 React 元素第一次转换为 Fiber 节点时，React 在 createFiberFromTypeAndProps 函数中使用元素中的数据来创建 Fiber。在随后的更新中，React 会再次利用 Fiber 节点，并使用来自相应 React 元素的数据更新必要的属性。如果不再从 render 方法返回相应的 React 元素，React 可能还需要根据 key 属性来移动或删除层级结构中的节点。</p>
<h3 id="3-3-Fiber-Tree"><a href="#3-3-Fiber-Tree" class="headerlink" title="3-3. Fiber Tree"></a>3-3. Fiber Tree</h3><p>上文提到 fiber tree 是链表结构，链表结构跟以往的 reactNode tree 相比，有着更高的遍历效率，并且是可暂停、撤销、重新开始的。</p>
<p><img src="https://tva3.sinaimg.cn/large/6f4890d4gy1gml775mk7lj20qy0kcgnt.jpg" alt="fiber-tree"></p>
<h3 id="3-4-current-tree-及-workInProgress-tree"><a href="#3-4-current-tree-及-workInProgress-tree" class="headerlink" title="3-4. current tree 及 workInProgress tree"></a>3-4. current tree 及 workInProgress tree</h3><p>在第一次渲染之后，React 最终得到一个 Fiber 树，它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为 current 树（当前树）。当 React 开始处理更新时，它会构建一个所谓的 workInProgress 树（工作过程树），它反映了要刷新到屏幕的未来状态。</p>
<p>所有工作都在 workInProgress 树的 Fiber 节点上执行。当 React 遍历 current 树时，对于每个现有 Fiber 节点，React 会创建一个构成 workInProgress 树的备用节点，这一节点会使用 render 方法返回的 React 元素中的数据来创建。处理完更新并完成所有相关工作后，React 将准备好一个备用树以刷新到屏幕。一旦这个 workInProgress 树在屏幕上呈现，它就会变成 current 树。这种方法我们称之为<strong>双缓冲技术 (double buffering)</strong></p>
<p>React 的核心原则之一是一致性。 React 总是一次性更新 DOM - 它不会显示部分中间结果。workInProgress 树充当用户不可见的「草稿」，这样 React 可以先处理所有组件，然后将其更改刷新到屏幕。<br>在源代码中，您将看到很多函数从 current 和 workInProgress 树中获取 Fiber 节点。这是一个这类函数的签名：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> update<span class="constructor">HostComponent(<span class="params">current</span>, <span class="params">workInProgress</span>, <span class="params">renderExpirationTime</span>)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Fiber节点持有备用域在另一个树的对应部分的引用。来自 current 树中的节点会指向 workInProgress 树中的节点，反之亦然。</p>
<p>这样做的好处：</p>
<ul>
<li>能够复用内部对象（fiber）</li>
<li>节省内存分配、GC的时间开销</li>
</ul>
<h3 id="3-5-优先级策略"><a href="#3-5-优先级策略" class="headerlink" title="3-5. 优先级策略"></a>3-5. 优先级策略</h3><p>每个工作单元运行时有6种优先级：</p>
<ul>
<li><strong>synchronous</strong> 与之前的Stack reconciler操作一样，同步执行</li>
<li><strong>task</strong> 在next tick之前执行</li>
<li><strong>animation</strong> 下一帧之前执行</li>
<li><strong>high</strong> 在不久的将来立即执行</li>
<li><strong>low</strong> 稍微延迟（100-200ms）执行也没关系</li>
<li><strong>offscreen</strong> 下一次render时或scroll时才执行</li>
</ul>
<p>synchronous 首屏（首次渲染）用，要求尽量快，不管会不会阻塞UI线程。animation 通过requestAnimationFrame 来调度，这样在下一帧就能立即开始动画过程；后3个都是由requestIdleCallback回调执行的；offscreen 指的是当前隐藏的、屏幕外的（看不见的）元素</p>
<p>高优先级的比如键盘输入（希望立即得到反馈），低优先级的比如网络请求，让评论显示出来等等。另外，紧急的事件是允许插队的。</p>
<h3 id="3-6-requestIdleCallback-和-requestAnimationFrame"><a href="#3-6-requestIdleCallback-和-requestAnimationFrame" class="headerlink" title="3-6. requestIdleCallback 和 requestAnimationFrame"></a>3-6. requestIdleCallback 和 requestAnimationFrame</h3><p>一些较新的浏览器提供了这个 API，我们可以看一下 MDN 上的介绍：</p>
<blockquote>
<p><code>window.requestIdleCallback()</code> 方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。</p>
</blockquote>
<p>函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 timeout，则有可能为了在超时前执行函数而打乱执行顺序。值得留意的是，为了兼顾更多的浏览器和确定空闲时间间隔等原因，React 是自己内部实现了一个 requestIdleCallback。</p>
<h3 id="3-7-工作循环"><a href="#3-7-工作循环" class="headerlink" title="3-7. 工作循环"></a>3-7. 工作循环</h3><p>所有的 Fiber 节点都会在 工作循环 中进行处理。如下是该循环的同步部分的实现：</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function workLoop(isYieldy) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isYieldy) &#123;</span><br><span class="line">    <span class="keyword">while</span> (nextUnitOfWork !== null) &#123;</span><br><span class="line">      nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="meta">&#123;...&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nextUnitOfWork 持有 workInProgress 树中的 Fiber 节点的引用，这个树有一些工作要做。当 React 遍历 Fiber 树时，它会使用这个变量来知晓是否有任何其他 Fiber 节点具有未完成的工作。处理过当前 Fiber 后，变量将持有树中下一个 Fiber 节点的引用或 null。在这种情况下，React 退出工作循环并准备好提交更改。<br>遍历树、初始化或完成工作主要用到 4 个函数：</p>
<ul>
<li>performUnitOfWork</li>
<li>beginWork</li>
<li>completeUnitOfWork</li>
<li>completeWork</li>
</ul>
<p>为了演示他们的使用方法，我们可以看看如下展示的遍历 Fiber 树的动画。我已经在演示中使用了这些函数的简化实现。每个函数都需要对一个 Fiber 节点进行处理，当 React 从树上下来时，您可以看到当前活动的 Fiber 节点发生了变化。从视频中我们可以清楚地看到算法如何从一个分支转到另一个分支。它首先完成子节点的工作，然后才转移到父节点进行处理。</p>
<p><img src="https://tvax2.sinaimg.cn/large/6f4890d4gy1gml78zehueg20lo0botn4.gif" alt="wookloop"></p>
<h3 id="3-7-reconciliation"><a href="#3-7-reconciliation" class="headerlink" title="3-7. reconciliation"></a>3-7. reconciliation</h3><p>以 fiber tree 为蓝本，把每个 fiber 作为一个工作单元，自顶向下逐节点构造 workInProgress tree（构建中的新 fiber tree）</p>
<p>具体过程如下（以组件节点为例）：</p>
<ol>
<li>如果当前节点不需要更新，直接把子节点 clone 过来，跳到5；要更新的话打个 tag</li>
<li>更新当前节点状态（props, state, context等）</li>
<li>调用 shouldComponentUpdate()，false 的话，跳到5</li>
<li>调用 render()获得新的子节点，并为子节点创建 fiber（创建过程会尽量复用现有 fiber，子节点增删也发生在这里）</li>
<li>如果没有产生 child fiber，该工作单元结束，把 effect list 归并到 return，并把当前节点的 sibling 作为下一个工作单元；否则把 child 作为下一个工作单元</li>
<li>如果没有剩余可用时间了，等到下一次主线程空闲时才开始下一个工作单元；否则，立即开始做</li>
<li>如果没有下一个工作单元了（回到了 workInProgress tree 的根节点），第 1 阶段结束，进入pendingCommit 状态</li>
</ol>
<p>际上是1-6的工作循环，7是出口，工作循环每次只做一件事，做完看要不要喘口气。工作循环结束时， workInProgress tree 的根节点身上的 effect list 就是收集到的所有 side effect（因为每做完一个都向上归并）</p>
<p>所以，构建 workInProgress tree 的过程就是 diff 的过程，通过 requestIdleCallback 来调度执行一组任务，每完成一个任务后回来看看有没有插队的（更紧急的），每完成一组任务，把时间控制权交还给主线程，直到下一次 requestIdleCallback 回调再继续构建 workInProgress tree</p>
<h2 id="4-参考资料"><a href="#4-参考资料" class="headerlink" title="4. 参考资料"></a>4. 参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://indepth.dev/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react">Inside Fiber: in-depth overview of the new reconciliation algorithm in React</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/acdlite/react-fiber-architecture">React Fiber Architecture</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/codebase-overview.html">Codebase Overview - React</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/reconciliation.html">Reconciliation - React</a></li>
<li><a target="_blank" rel="noopener" href="https://indepth.dev/posts/1007/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree">The how and why on React’s usage of linked list in Fiber to walk the component’s tree</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37095662">React Fiber架构 - 司徒正美</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ayqy.net/blog/dive-into-react-fiber">完全理解React Fiber</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame">window.requestAnimationFrame - Web API 接口参考 | MDN</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback">requestIdleCallback - Web API 接口参考 | MDN</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React-fiber/" rel="tag">React fiber</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React-%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/" rel="tag">React 源码学习</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-map-usebook" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2020/06/07/map-usebook/" class="article-date">
  	<time datetime="2020-06-06T16:00:00.000Z" itemprop="datePublished">2020-06-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/07/map-usebook/">前端地图基本原理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端地图基本原理"><a href="#前端地图基本原理" class="headerlink" title="前端地图基本原理"></a>前端地图基本原理</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-经纬度的描述"><a href="#1-1-经纬度的描述" class="headerlink" title="1-1. 经纬度的描述"></a>1-1. 经纬度的描述</h3><p>地球是一个椭球，Datum 是一组用于描述这个椭球的数据集合。最常用的一个 Datum 是 WGS84 (World Geodetic System 1984)，它的主要参数有：</p>
<ul>
<li>坐标系的原点是<strong>地球质心</strong>（center of mass）</li>
<li><strong>子午线</strong>（meridian），即零度经线，位于格林威治子午线 Royal Observatory 所在纬度往东 102.5米 所对应的的经线圈</li>
<li>椭球截面长轴为 a=6378137米</li>
<li>椭圆截面短轴为 b=6356752.3142米，可选参数</li>
<li>扁平比例（flattening）f=(a−b)/a=1/298.257223563</li>
<li>geoid，即海平面，用于定义高度</li>
</ul>
<h3 id="1-2-像素坐标系"><a href="#1-2-像素坐标系" class="headerlink" title="1-2. 像素坐标系"></a>1-2. 像素坐标系</h3><p>像素坐标系，也可以成为屏幕坐标系，像素坐标系和地图的经纬度坐标系存在对应关系，屏幕上的每一个像素都对应一个经纬度点位置。 不同缩放级别下，像素坐标系和经纬度坐标系的对应关系是不同的。</p>
<h3 id="1-3-投影"><a href="#1-3-投影" class="headerlink" title="1-3. 投影"></a>1-3. 投影</h3><p>地图投影是利用一定数学法则把地球表面的经、纬线转换到平面上的理论和方法。由于地球是一个赤道略宽两极略扁的不规则的梨形球体，故其表面是一个不可展平的曲面，所以运用任何数学方法进行这种转换都会产生误差和变形，为按照不同的需求缩小误差，就产生了各种投影方法。</p>
<p><img src="https://tvax3.sinaimg.cn/large/6f4890d4gy1gml736pl3dj20lz0abacn.jpg" alt="map_projection"></p>
<p>关于投影我们只需要了解<strong>墨卡托投影</strong>（正轴等角圆柱投影）</p>
<h3 id="1-4-墨卡托投影"><a href="#1-4-墨卡托投影" class="headerlink" title="1-4. 墨卡托投影"></a>1-4. 墨卡托投影</h3><p><strong>墨卡托投影</strong>，是正轴等角圆柱投影。由荷兰地图学家墨卡托 (G.Mercator) 于 1569 年创立。假想一个与地轴方向一致的圆柱切或割于地球，按等角条件，将经纬网投影到圆柱面上，将圆柱面展为平面后，即得本投影。等角条件是使地球面上微分区域内两个方向的夹角投影到平面以后，保持角度不变的条件。</p>
<p>而 <strong>Web 墨卡托投影</strong>（又称球体墨卡托投影）是墨卡托投影的变种，它接收的输入是 Datum 为 WGS84 的经纬度，但在投影时不再把地球当做椭球而当做半径为 6378137 米的标准球体，以简化计算。</p>
<p><img src="https://tvax1.sinaimg.cn/large/6f4890d4gy1gml73igva7j20m809tq5m.jpg" alt="mercator_projection"></p>
<p>Web 墨卡托投影的两个投影标准：</p>
<ul>
<li>EPSG4326：Web 墨卡托投影后的平面地图，但仍然使用 WGS84 的经度、纬度表示坐标；</li>
<li>EPSG3857：Web 墨卡托投影后的平面地图，坐标单位为米。</li>
</ul>
<p>这两个投影标准在我们调用 geoserver 的服务时可能会用到，所以简单了解即可。</p>
<h3 id="1-5-瓦片"><a href="#1-5-瓦片" class="headerlink" title="1-5. 瓦片"></a>1-5. 瓦片</h3><p>经过投影后，地图就变为平面的一张地图。考虑到有时候我们需要看宏观的地图信息（如世界地图里每个国家的国界），有时候又要看很微观的地图信息（如导航时道路的路况信息）。为此，我们对这张地图进行等级切分。在最高级 (zoom=0)，需要的信息最少，只需保留最重要的宏观信息，因此用一张 256x256 像素的图片表示即可；在下一级 (zoom=1)，信息量变多，用一张 512x512 像素的图片表示；以此类推，级别越低的像素越高，下一级的像素是当前级的4倍。这样从最高层级往下到最低层级就形成了一个金字塔坐标体系。</p>
<p>对每张图片，我们将其切分为 256x256 的图片，称为<strong>瓦片</strong>（Tile）。这样，在最高级 (zoom=0) 时，只有一个瓦片；在下一级 (zoom=1) 时有4个瓦片；在下一级 (zoom=2) 时有16个瓦片，以此类推。</p>
<p><img src="https://tva4.sinaimg.cn/large/6f4890d4gy1gml73sflzwj20m80azjzd.jpg" alt="conversion_of_coordinates"></p>
<h3 id="1-6-瓦片的编号"><a href="#1-6-瓦片的编号" class="headerlink" title="1-6. 瓦片的编号"></a>1-6. 瓦片的编号</h3><p>瓦片生成后，就是一堆图片。怎么对这堆图片进行编号，是目前主流互联网地图商分歧最大的地方。总结起来分为四个流派：</p>
<ul>
<li>谷歌 XYZ：Z 表示缩放层级，Z=zoom；XY 的原点在左上角，X 从左向右，Y 从上向下。</li>
<li>TMS：开源产品的标准，Z 的定义与谷歌相同；XY 的原点在左下角，X 从左向右，Y 从下向上。</li>
<li>QuadTree：微软 Bing 地图使用的编码规范，Z 的定义与谷歌相同，同一层级的瓦片不用 XY 两个维度表示，而只用一个整数表示，该整数服从四叉树编码规则</li>
<li>百度 XYZ：Z 从 1 开始，在最高级就把地图分为四块瓦片；XY 的原点在经度为 0 纬度位 0 的位置，X 从左向右，Y 从下向上</li>
</ul>
<p><img src="https://tvax3.sinaimg.cn/large/6f4890d4gy1gml7430o2xj20m80lk48f.jpg" alt="tile_coding"></p>
<h2 id="2-Geoserver"><a href="#2-Geoserver" class="headerlink" title="2. Geoserver"></a>2. Geoserver</h2><p>先看一段官方的介绍：</p>
<blockquote>
<p><strong>GeoServer</strong> 是基于 Java 的软件服务器，允许用户查看和编辑地理空间数据。使用开放地理空间联盟（OGC）提出的开放标准，GeoServer 在地图创建和数据共享方面具有极大的灵活性。<br>GeoServer 允许您向世界显示您的空间信息。实施Web地图服务 (WMS) 标准，GeoServer 可以创建各种输出格式的地图。一个免费的地图库 <strong>OpenLayers</strong> 已集成到 GeoServer 中，从而使地图生成快速简便。<br>GeoServer 符合 Web Feature Service（WFS）标准和 Web Coverage Service（WCS）标准，该标准允许共享和编辑用于生成地图的数据。GeoServer 还使用 Web Map Tile Service 标准将您发布的地图拆分为图块，以方便Web地图和移动应用程序使用。</p>
</blockquote>
<p>GeoServer 使用的是图层与图层组的概念。将在服务器上准备发布为服务的数据定义为一组数据集，然后规定在发布为Web服务时的一些参数。Geoserve 提供了操作界面来管理各种配置：</p>
<p><img src="https://tvax3.sinaimg.cn/large/6f4890d4gy1gml74b6kwbj217f0ot0vb.jpg" alt="geoserver_page"></p>
<h2 id="3-leaflet-和-openlayers"><a href="#3-leaflet-和-openlayers" class="headerlink" title="3. leaflet 和 openlayers"></a>3. leaflet 和 openlayers</h2><p>上文说到的 <strong>openlayers</strong> 和 <strong>leaflet</strong> 都是用于在 Web 上创建交互式地图，可以显示从任何来源加载的地图图块、矢量数据和标记。</p>
<p>这里的两者都是开源的，相比起来 leaflet 更加轻量，适合移动端的场景，如果只是相对简单的地图需求，使用 leaflet 会是一个合适的选择。而 openlayers 具有数量更大，更复杂的 API。而 geoserver 提供的服务，对  leaflet 和 openlayers 都是支持的。</p>
<h2 id="4-调用-geoserver-的服务"><a href="#4-调用-geoserver-的服务" class="headerlink" title="4. 调用 geoserver 的服务"></a>4. 调用 geoserver 的服务</h2><h3 id="4-1-调用-WMS"><a href="#4-1-调用-WMS" class="headerlink" title="4-1. 调用 WMS"></a>4-1. 调用 WMS</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wmsLayer = <span class="built_in">Map</span>.tileLayer.wms(</span><br><span class="line">  <span class="string">&#x27;http://gsmap.sf-express.com/geoserver/sfmap/wms&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    type: <span class="string">&#x27;tile&#x27;</span>,</span><br><span class="line">    layers: <span class="string">&#x27;map:example_layer&#x27;</span>,</span><br><span class="line">    version: <span class="string">&#x27;1.1.1&#x27;</span>,</span><br><span class="line">    format: <span class="string">&#x27;image/png&#x27;</span>,</span><br><span class="line">    request: <span class="string">&#x27;GetMap&#x27;</span>,</span><br><span class="line">    transparent: <span class="string">&#x27;true&#x27;</span>,</span><br><span class="line">    zoom: [<span class="number">3</span>, <span class="number">20</span>],</span><br><span class="line">    zIndex: <span class="number">5</span>,</span><br><span class="line">    sld_body: getSld(<span class="string">&#x27;sfmap:dept_3&#x27;</span>, <span class="built_in">this</span>.cateMapData),</span><br><span class="line"> &#125;,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.mapIns.addLayer(wmsLayer)</span><br></pre></td></tr></table></figure>
<p>此处使用 <code>Map.tileLayer.wms(url, params)</code> 调用来自 geoserver 的 WMS 服务，使用的参数如下：</p>
<ul>
<li><strong>url</strong>：请求的 geoserver 服务地址</li>
<li><strong>params</strong>：请求的目标图层相关配置参数，<code>layers</code> 为请求的图层名，在 geoserver 服务中不同维度的地图图层对应不同的名字，在这里的 <code>dept_3</code> 表示业务区的地图图层；<code>request</code> 表示此处调用的是 geoserver 的获取地图图层的服务；<code>format</code> 和 <code>tranparent</code>表示请求的瓦片图文件格式及背景是否透明； 而 <code>sld_body</code> 则是需要自定义的 SLD 样式</li>
</ul>
<h3 id="4-2-配置-SLD"><a href="#4-2-配置-SLD" class="headerlink" title="4-2. 配置 SLD"></a>4-2. 配置 SLD</h3><p>对于 WMS 返回的地图图层，可以针对之进行样式的自定义，geoserver 支持多种方法定义图层样式，<strong>SLD</strong> 就是其中一种。</p>
<blockquote>
<p>SLD (Style Layer Descriptor) 是2005年OGC提出的一个标准，这个标准在一定条件下允许WMS服务器对地图可视化的表现形式进行扩展。该 SLD 规范是采用XML定义地图显示样式，通过自定义SLD来配置地图图层渲染的可视化风格，可以设置过滤器，自定义图例等。</p>
</blockquote>
<p><img src="https://tva2.sinaimg.cn/large/6f4890d4gy1gml74is7huj20co08aaa5.jpg" alt="SLD_structure"></p>
<p>如果我们想要自定义图层的样式，肯定会用到的元素包括：</p>
<ul>
<li><p><strong>FeatureTypeStyle</strong>：这一部分是整个样式文档的根节点，并说明什么是它的样式将被应用的特征类型。FeatureTypeStyle 包含一个或者多个 Rule 元素，Rule 元素允许有条件的映射。</p>
</li>
<li><p><strong>RULE</strong>（规则）：规则是根据属性条件和地图比例尺来对要素进行分组渲染，一般 RULE 中只允许渲染一种类型的要素，即点，线，面等其中的一种，但是可以和注记同时使用。</p>
</li>
<li><p><strong>Symbolizer</strong>（符号）：Symbolizer 指定数据应该如何可视化，在1.0的标准中包含五忠类型的Symbolizer，分别是PointSymbolizer（点符号）、LineSymbolizer（线符号）、PloygonSymbolizer（面符号）、TextSymbolizer（注记）、RasterSymbolizer（栅格）。</p>
</li>
</ul>
<p>除了一些预设的匹配规则，SLD 还提供了一些 <code>Function</code> 可应用于较为负责的筛选。</p>
<p>以实际应用举例，见以下代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Rule</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ogc:Filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ogc:PropertyIsEqualTo</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ogc:Function</span> <span class="attr">name</span>=<span class="string">&quot;in&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ogc:PropertyName</span>&gt;</span>code<span class="tag">&lt;/<span class="name">ogc:PropertyName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ogc:Literal</span>&gt;</span>591Y<span class="tag">&lt;/<span class="name">ogc:Literal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ogc:Literal</span>&gt;</span>592Y<span class="tag">&lt;/<span class="name">ogc:Literal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ogc:Literal</span>&gt;</span>595Y<span class="tag">&lt;/<span class="name">ogc:Literal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ogc:Literal</span>&gt;</span>791Y<span class="tag">&lt;/<span class="name">ogc:Literal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ogc:Function</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ogc:Literal</span>&gt;</span>true<span class="tag">&lt;/<span class="name">ogc:Literal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ogc:PropertyIsEqualTo</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ogc:Filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PolygonSymbolizer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Fill</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CssParameter</span> <span class="attr">name</span>=<span class="string">&quot;fill&quot;</span>&gt;</span>#7ba7ee<span class="tag">&lt;/<span class="name">CssParameter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CssParameter</span> <span class="attr">name</span>=<span class="string">&quot;fill-opacity&quot;</span>&gt;</span>0.7<span class="tag">&lt;/<span class="name">CssParameter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Fill</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Stroke</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CssParameter</span> <span class="attr">name</span>=<span class="string">&quot;stroke&quot;</span>&gt;</span>#727D71<span class="tag">&lt;/<span class="name">CssParameter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">CssParameter</span> <span class="attr">name</span>=<span class="string">&quot;stroke-width&quot;</span>&gt;</span>0.4<span class="tag">&lt;/<span class="name">CssParameter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Stroke</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PolygonSymbolizer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Rule</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段 SLD 表示对数据对象进行筛选匹配，当对象的 code 属性为 591Y、592Y、595Y 和 791Y 四者的其一时，适用后续的样式。后续的样式表示对应的 PolygonSymbolizer 元素适用了 Fill 和 Stroke 的样式，具体的样式属性分别是填充颜色、填充透明度、边界颜色和边界宽度。</p>
<p>这里需要留意的是任何 Function 元素都会有一个返回值， <code>&lt;ogc:Function name=&quot;in&quot;&gt;&lt;/ogc:Function&gt;</code> 对应的返回值是一个 Boolean 值，所以需要在后面紧跟 <code>&lt;ogc:Literal&gt;true&lt;/ogc:Literal&gt;</code> 来对应返回值的匹配。</p>
<h3 id="4-3-获取点击位置所属业务区"><a href="#4-3-获取点击位置所属业务区" class="headerlink" title="4-3. 获取点击位置所属业务区"></a>4-3. 获取点击位置所属业务区</h3><p>还是看例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听地图的点击事件</span></span><br><span class="line"><span class="built_in">this</span>.mapIns.on(<span class="string">&#x27;click&#x27;</span>, getClickFeature)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">getClickFeature</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; containerPoint &#125; = e</span><br><span class="line">  <span class="keyword">const</span> bbox = <span class="built_in">this</span>.mapIns.getBounds().toBBoxString()</span><br><span class="line">  <span class="keyword">const</span> size = <span class="built_in">this</span>.mapIns.getSize()</span><br><span class="line">  <span class="keyword">const</span> url =</span><br><span class="line">    <span class="string">`http://gsmap.sf-express.com/geoserver/sfmap/wms`</span> +</span><br><span class="line">    <span class="string">`?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetFeatureInfo&amp;`</span> +</span><br><span class="line">    <span class="string">`FORMAT=image%2Fpng&amp;TRANSPARENT=true&amp;QUERY_LAYERS=map%3Aexample_layer`</span> +</span><br><span class="line">    <span class="string">`&amp;LAYERS=sfmap%3Adept_3&amp;CRS=EPSG%3A4326&amp;`</span> +</span><br><span class="line">    <span class="string">`INFO_FORMAT=text%2Fjavascript&amp;FEATURE_COUNT=1000`</span> +</span><br><span class="line">    <span class="string">`&amp;X=<span class="subst">$&#123;containerPoint.x&#125;</span>&amp;Y=<span class="subst">$&#123;containerPoint.y&#125;</span>`</span> +</span><br><span class="line">    <span class="string">`&amp;WIDTH=<span class="subst">$&#123;size.x&#125;</span>&amp;HEIGHT=<span class="subst">$&#123;size.y&#125;</span>`</span> +</span><br><span class="line">    <span class="string">`&amp;SRS=EPSG%3A4326&amp;STYLES=&amp;BBOX=<span class="subst">$&#123;bbox&#125;</span>`</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getResult</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (res) &#123;</span><br><span class="line">      <span class="comment">// 根据返回的数据结构区域编码</span></span><br><span class="line">      <span class="keyword">const</span> &#123; features &#125; = res</span><br><span class="line">      <span class="keyword">if</span> (features.length) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">          properties: &#123; code &#125;,</span><br><span class="line">        &#125; = features[<span class="number">0</span>]</span><br><span class="line">        vm.$emit(<span class="string">&#x27;areaClick&#x27;</span>, code) <span class="comment">// 获取到点击位置所属的业务区</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.jsonp(url, getResult) <span class="comment">// 通过 jsonp 的方式跨域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>geoserver 的 GetFeatureInfo 服务支持通过 jsonp 的方式调用，通过组装地址的方式就可以实现请求获取点击位置的所属业务区了，简单看一下请求参数：</p>
<ul>
<li><strong>CRS</strong> Coordinate Reference System, 即上文提到的投影标准，这里使用的是 EPSG4326</li>
<li><strong>INFO_FORMAT</strong> 使用 jsonp 调用所需要的传参</li>
<li><strong>FEATURE_COUNT</strong> 查询命中的数据对象取数上限</li>
<li><strong>X</strong>, <strong>Y</strong> 在地图上的点击坐标，以地图容器左上为原点的坐标值</li>
<li><strong>WIDTH</strong>, <strong>HEIGHT</strong> 地图容器的尺寸</li>
<li><strong>BBOX</strong> Bounds Box, 当前所显示地图的四个角对应的经纬度</li>
</ul>
<p>geoserver 主要是通过 X, Y, WIDTH, HEIGHT 和 BBOX 来定位到具体的点击位置，需要注意受限于地图缩放等级和容器大小等因素，最终的返回值可能不止一个。</p>
<blockquote>
<p><strong>扩展参考：</strong><br><a target="_blank" rel="noopener" href="https://leafletjs.com/">Leaflet - a JavaScript library for interactive maps</a><br><a target="_blank" rel="noopener" href="https://openlayers.org/">OpenLayers - A high-performance, feature-packed library for all your mapping needs.</a><br><a target="_blank" rel="noopener" href="https://docs.geoserver.org/latest/en/user/styling/sld/index.html">SLD Styling — GeoServer 2.19.x User Manual</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tuboshu/p/10752292.html">GeoServer中使用SLD样式</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e9e83b427045">瓦片地图原理</a></p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Geoserver/" rel="tag">Geoserver</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SLD/" rel="tag">SLD</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leaflet/" rel="tag">leaflet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openlayers/" rel="tag">openlayers</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9C%B0%E5%9B%BE/" rel="tag">地图</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-e2e-test-n-nightmare" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/29/e2e-test-n-nightmare/" class="article-date">
  	<time datetime="2018-03-28T16:00:00.000Z" itemprop="datePublished">2018-03-29</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/29/e2e-test-n-nightmare/">E2E 测试与自动化测试工具 Nightmare</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-前端的自动化测试"><a href="#1-前端的自动化测试" class="headerlink" title="1. 前端的自动化测试"></a>1. 前端的自动化测试</h1><h2 id="1-2-单元测试"><a href="#1-2-单元测试" class="headerlink" title="1.2 单元测试"></a>1.2 单元测试</h2><p><strong>单元测试</strong>往往只关注于一个代码片段，通常是一个模块或函数。实际应用中会将代码拆分成若干个小的组件，这也意味着你会写很多的单元测试用例来保证代码的功能正常。</p>
<p>前端开发中的单元测试工具有 <a target="_blank" rel="noopener" href="https://facebook.github.io/jest/zh-Hans/">jest</a>、<a target="_blank" rel="noopener" href="https://mochajs.org/">mocha</a>、<a target="_blank" rel="noopener" href="https://jasmine.github.io/">jasmine</a> 和 <a target="_blank" rel="noopener" href="https://qunitjs.com/">qunit</a>。</p>
<h2 id="1-3-E2E-测试"><a href="#1-3-E2E-测试" class="headerlink" title="1.3. E2E 测试"></a>1.3. E2E 测试</h2><p><strong>E2E</strong>（end to end）测试即<strong>端到端测试</strong>是，也称冒烟测试，用于测试真实浏览器环境下前端应用的流程和表现，相当于代替人工去操作应用。E2E 测试是一个边界比较模糊的概念，有以下几个特点：</p>
<ul>
<li>把整个系统当作一个黑盒</li>
<li>测试人员模拟真实用户在浏览器中操作UI</li>
<li>测试出的问题可能是前端也可能是后端导致的</li>
</ul>
<p>常见的 E2E 测试工具有 <a target="_blank" rel="noopener" href="http://www.nightmarejs.org/">nightmare</a>、nightwatch 和 <a target="_blank" rel="noopener" href="https://github.com/googlechrome/puppeteer">puppeteer</a>。</p>
<h2 id="1-4-单元测试和-E2E-测试的对比"><a href="#1-4-单元测试和-E2E-测试的对比" class="headerlink" title="1.4. 单元测试和 E2E 测试的对比"></a>1.4. 单元测试和 E2E 测试的对比</h2><p>单元测试的概念出现已久，相关的工具体系也已经十分完善，但是单元测试的维护成本较高，并且对于前端测试来说有很多需求无法满足。此外，单元测试需要较多的角度完善的测试用例支持，且这些测试用例都是较为简单的，针对每一个小模块或者组建的输入与输出。</p>
<p>E2E 测试针对具体的测试环境条件来编写测试用例，一般情况下测试用例不会太多.</p>
<h2 id="1-5-TDD-和-BDD"><a href="#1-5-TDD-和-BDD" class="headerlink" title="1.5. TDD 和 BDD"></a>1.5. TDD 和 BDD</h2><p><strong>TDD</strong>（Test Drive Development）即<strong>测试驱动开发</strong>。简单的说就是先根据需求写测试用例，再代码实现，接着测试，循环此过程直到产品的实现。可以看出来，TDD 的基本思路就是通过测试来推动整个开发的进行，但测试驱动开发并不只是单纯的测试工作，而是把需求分析，设计，质量控制量化的过程。</p>
<p><strong>BDD</strong>（Behavior Drive Development）即<strong>行为驱动开发</strong>，BDD 可以看作是对 TDD 的一种补充，或者说是 TDD 的一个分支。在TDD中，我们并不能完全保证根据设计所编写的测试就是用户所期望的功能。BDD将这一部分简单和自然化，用自然语言来描述，让开发、测试、BA以及客户都能在这个基础上达成一致。BDD 更加依赖于需求行为和文档来驱动开发，这些文档的描述跟测试代码很相似。</p>
<p>通过对比，TDD 通过测试来推动整个开发的进行。这有助于编写简洁可用和高质量的代码，并加速实际开发过程，可能导致的问题是需求和开发脱节，实际产品与用户所需要的功能并不匹配。而 BDD 通过鼓励项目中的开发者、QA 和非技术人员或商业参与者之间进行协作，确保程序实现效果与用户需求一致。</p>
<p>可以看出 <strong>E2E 测试</strong>更多的是换和 <strong>BDD</strong> 的开发模式进行结合,实际应用用会将 E2E 的测试工具和 BDD 测试框架进行结合。</p>
<h1 id="2-Nightmare"><a href="#2-Nightmare" class="headerlink" title="2. Nightmare"></a>2. Nightmare</h1><h2 id="2-1-基本介绍"><a href="#2-1-基本介绍" class="headerlink" title="2.1.基本介绍"></a>2.1.基本介绍</h2><p>Nightmare 是一个基于 electron 的浏览器自动化代码库，用于实现爬虫或自动化测试。相较于传统的爬虫框架（scrapy/pyspider），或者dom操作库（cheerio/jsdom），或者基于浏览器的自动化框架（selenium/phantomjs），他的优势在于提供了一个<strong>简洁有效</strong>的编程模型。</p>
<p>官网给出的实现一个向yahoo自动提交关键词并搜索的功能如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">yield</span> Nightmare()</span><br><span class="line">  .goto(<span class="string">&#x27;http://yahoo.com&#x27;</span>)</span><br><span class="line">  .type(<span class="string">&#x27;input[title=&quot;Search&quot;]&#x27;</span>, <span class="string">&#x27;github nightmare&#x27;</span>)</span><br><span class="line">  .click(<span class="string">&#x27;.searchsubmit&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2-2-相关-API"><a href="#2-2-相关-API" class="headerlink" title="2.2. 相关 API"></a>2.2. 相关 API</h2><p>基本的交互 API 包括：</p>
<ul>
<li><code>goto(url[, headers])</code> 跳转到url</li>
<li><code>viewport(width,</code> height) 浏览器窗口大小</li>
<li><code>wait(selector)</code> 等待某个dom元素出现</li>
<li><code>click(selector)</code> 点击某个dom元素</li>
<li><code>type(selector[, text])</code> 在某个dom元素中输入</li>
<li><code>inject(type, file)</code> 在页面上挂载 js/css 文件内容</li>
<li><code>evaluate(fn[, arg1, arg2,...])</code> 在客户端注入JS脚本并执行，从而实现electron模型下的C/S互动及数据交换</li>
<li>……</li>
</ul>
<h2 id="2-3-实例"><a href="#2-3-实例" class="headerlink" title="2.3. 实例"></a>2.3. 实例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Nightmare <span class="keyword">from</span> <span class="string">&#x27;nightmare&#x27;</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;Login&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> page;</span><br><span class="line">  beforeEach(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    page = Nightmare();</span><br><span class="line">    page.goto(<span class="string">&#x27;http://localhost:8000/#/user/login&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should login with failure&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> page.type(<span class="string">&#x27;#userName&#x27;</span>, <span class="string">&#x27;mockuser&#x27;</span>)</span><br><span class="line">      .type(<span class="string">&#x27;#password&#x27;</span>, <span class="string">&#x27;wrong_password&#x27;</span>)</span><br><span class="line">      .click(<span class="string">&#x27;button[type=&quot;submit&quot;]&#x27;</span>)</span><br><span class="line">      .wait(<span class="string">&#x27;.ant-alert-error&#x27;</span>) <span class="comment">// should display error</span></span><br><span class="line">      .end();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&#x27;should login successfully&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> text = <span class="keyword">await</span> page.type(<span class="string">&#x27;#userName&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">      .type(<span class="string">&#x27;#password&#x27;</span>, <span class="string">&#x27;888888&#x27;</span>)</span><br><span class="line">      .click(<span class="string">&#x27;button[type=&quot;submit&quot;]&#x27;</span>)</span><br><span class="line">      .wait(<span class="string">&#x27;.ant-layout-sider h1&#x27;</span>) <span class="comment">// should display error</span></span><br><span class="line">      .evaluate(<span class="function">() =&gt;</span> <span class="built_in">document</span>.body.innerHTML)</span><br><span class="line">      .end();</span><br><span class="line">    expect(text).toContain(<span class="string">&#x27;&lt;h1&gt;Ant Design Pro&lt;/h1&gt;&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> expect = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>).expect;</span><br><span class="line"><span class="keyword">const</span> Nightmare = <span class="built_in">require</span>(<span class="string">&#x27;nightmare&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;simulate search&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="built_in">this</span>.timeout(<span class="string">&#x27;30s&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">　　<span class="keyword">let</span> nightmare = <span class="literal">null</span></span><br><span class="line">　　beforeEach(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">　　　　<span class="comment">// 设置显示模拟弹框</span></span><br><span class="line">　　　　nightmare = <span class="keyword">new</span> Nightmare(&#123;</span><br><span class="line">　　　　show: <span class="literal">true</span>,</span><br><span class="line">　　　&#125;)</span><br><span class="line">　　&#125;)</span><br><span class="line"> </span><br><span class="line">　　it(<span class="string">&#x27;模拟用户搜索&#x27;</span>, <span class="function"><span class="params">done</span> =&gt;</span> &#123;</span><br><span class="line">　　　　nightmare</span><br><span class="line">　　　　.goto(<span class="string">&#x27;https://www.baidu.com/&#x27;</span>)  <span class="comment">//设置搜索引擎</span></span><br><span class="line">　　　　.viewport(<span class="number">1200</span>, <span class="number">672</span>) 　 <span class="comment">//设置弹框视口宽高　　　　　　　　</span></span><br><span class="line">　　　　.type(<span class="string">&#x27;form[action*=&quot;/s&quot;] [name=wd]&#x27;</span>, <span class="string">&#x27;github nightmare&#x27;</span>)   <span class="comment">//获取搜索框，自动填充搜索内容</span></span><br><span class="line">　　　　.click(<span class="string">&#x27;form[action*=&quot;/s&quot;] [type=submit]&#x27;</span>)  <span class="comment">//获取点击按钮，模拟点击</span></span><br><span class="line">　　　　.wait(<span class="number">5000</span>) <span class="comment">//等待5s(可为dom节点)，获取第一条的信息的内容</span></span><br><span class="line">　　　　.evaluate(<span class="function">() =&gt;</span></span><br><span class="line">　　　　　<span class="built_in">document</span>.querySelector(<span class="string">&#x27;#content_left .c-container a em&#x27;</span>).innerHTML</span><br><span class="line">　　　　)</span><br><span class="line">　　　　.end()</span><br><span class="line">　　　　.then(<span class="function"><span class="params">content</span> =&gt;</span> &#123;</span><br><span class="line">　　　　　<span class="built_in">console</span>.log(content === <span class="string">&#x27;Nightmare&#x27;</span>,<span class="string">&#x27;-----&gt;true&#x27;</span>)  <span class="comment">//输出结果</span></span><br><span class="line">		  done();</span><br><span class="line">　　　　&#125;)</span><br><span class="line">　　　　.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">　　　　　<span class="built_in">console</span>.error(<span class="string">&#x27;Search failed:&#x27;</span>, error);  <span class="comment">//输出捕捉到的错误</span></span><br><span class="line">		  done();</span><br><span class="line">　　　　&#125;);</span><br><span class="line">　　&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008915567">测试你的前端代码 - part3（端到端测试）</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/E2E-%E6%B5%8B%E8%AF%95/" rel="tag">E2E 测试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Nightmare/" rel="tag">Nightmare</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" rel="tag">单元测试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/" rel="tag">自动化测试</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-base64-convert-to-upload" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/02/base64-convert-to-upload/" class="article-date">
  	<time datetime="2018-03-01T16:00:00.000Z" itemprop="datePublished">2018-03-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/02/base64-convert-to-upload/">Base64 图片数据转换上传</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-base64"><a href="#1-base64" class="headerlink" title="1. base64"></a>1. base64</h1><h2 id="1-1-背景介绍"><a href="#1-1-背景介绍" class="headerlink" title="1.1. 背景介绍"></a>1.1. 背景介绍</h2><blockquote>
<p>Base64是网络上最常见的用于传输 8Bit 字节码的编码方式之一，Base64 就是一种基于 64 个可打印字符来表示二进制数据的方法。</p>
</blockquote>
<p>用记事本打开exe、jpg、pdf这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64 就是一种最常见的二进制编码方法。</p>
<p>简单的说，Base64 将 8 位的非英语字符转化为 7 位的 ASCII 字符。最初为了解决电子邮件中不能直接使用非 ASCII 码字符的问题而被提出，除此之外还有别的意义：</p>
<ul>
<li>所有的二进制文件，都可以因此转化为可打印的文本编码，使用文本软件进行编辑</li>
<li>能够对文本进行简单的加密</li>
</ul>
<h2 id="1-2-原理简析"><a href="#1-2-原理简析" class="headerlink" title="1.2. 原理简析"></a>1.2. 原理简析</h2><p>Base64，就是说选出64个字符：</p>
<ul>
<li>小写字母 a-z</li>
<li>大写字母 A-Z</li>
<li>数字 0-9</li>
<li>符号 “+”、”/“</li>
</ul>
<p>实际上还有作为垫字的“=”，所以在一段 base64 文本中会看到 65 个字符。将除了ASCII字符以外的其他所有符号都转换成这个字符集中的字符。</p>
<p>Base64 对二进制数据进行处理，每 3 个字节一组，一共是 3 x 8 = 24bit，划为4组，每组正好 6 个 bit：</p>
<p>得到四个 6 位的数据之后给每一个开头加上 <code>00</code>，这样 3 个字节的数据就转成了 4 个字节。正是因此经过 Base64 编码过的数据会在大小上增加 33% 左右。</p>
<p>如果要编码的二进制数据不是 3 的倍数，实际编码可能会在最后剩下 1 个或 2 个字节，Base64用 <code>\x00</code> 字节在末尾补足后，再在编码的末尾加上 1 个或 2 个 = 号，表示补了多少字节，在解码的时候，会自动去掉。</p>
<h1 id="2-相关方法"><a href="#2-相关方法" class="headerlink" title="2. 相关方法"></a>2. 相关方法</h1><h2 id="2-1-window-atob-和-window-btoa"><a href="#2-1-window-atob-和-window-btoa" class="headerlink" title="2.1. window.atob() 和 window.btoa()"></a>2.1. <code>window.atob()</code> 和 <code>window.btoa()</code></h2><p>在JavaScript中，有 2 个函数分别用来处理解码和编码 Base64 字符串：</p>
<ul>
<li><code>window.atob()</code>：对用 Base64 编码过的字符串进行解码</li>
<li><code>window.btoa()</code>：从 String 对象中创建一个 Base64 编码的 ASCII 字符串，其中字符串中的每个字符都被视为一个二进制数据字节</li>
</ul>
<h2 id="2-2-Uint8Array"><a href="#2-2-Uint8Array" class="headerlink" title="2.2. Uint8Array"></a>2.2. Uint8Array</h2><p><code>Uint8Array</code> 数组类型表示一个 8 位无符号整型数组，创建时内容被初始化为 0。</p>
<p>创建完后，可以以对象的方式或使用数组下标索引的方式引用数组中的元素。</p>
<h2 id="2-3-Blob"><a href="#2-3-Blob" class="headerlink" title="2.3. Blob"></a>2.3. Blob</h2><p>Blob 对象表示一个不可变、原始数据的类文件对象。Blob 表示的不一定是 JavaScript 原生格式的数据。File 接口基于Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<p>要构建一个 Blob 对象可以使用 <code>Blob()</code> 构造函数：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const aBlob = <span class="keyword">new</span> <span class="constructor">Blob( <span class="params">array</span>, <span class="params">options</span> )</span>;</span><br></pre></td></tr></table></figure>
<p><code>Blob()</code> 构造函数返回的 Blob 对象内容由参数数组中给出的值的串联组成。参数如下：</p>
<ul>
<li>array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8</li>
<li>options 是一个可选的 BlobPropertyBag 字典，它可能会指定如下两个属性：key 和 ending</li>
</ul>
<h1 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3. 具体实现"></a>3. 具体实现</h1><p>为了将 Base64 数据转换成二进制的数据进行上传，可以分成以下几个步骤：</p>
<ol>
<li>去掉 Base64 图片数据字串中开头一些类型说明的内容</li>
<li>取出 Base64 图片数据字串中的 MIME 说明</li>
<li>用 <code>window.atob()</code> 解码 Base64 转换成图片原生的数据字串</li>
<li>将得到的图片原生字串放入 Uint8Array</li>
<li>转换成 Blob 格式</li>
<li>调用 FormData 的 <code>append()</code> 插入 Blob 数据，连同 form 中的数据一同发送</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将base64转换成二进制图片（Blob）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURItoBlob</span> (<span class="params">base64Data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> byteString = <span class="built_in">window</span>.atob(base64Data.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">1</span>]); <span class="comment">// 去掉url的头，是一段类型说明</span></span><br><span class="line">  <span class="keyword">const</span> mimeString = base64Data.split(<span class="string">&#x27;,&#x27;</span>)[<span class="number">0</span>].split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">1</span>].split(<span class="string">&#x27;;&#x27;</span>)[<span class="number">0</span>]; <span class="comment">// 取出 MIME类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> ia = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(byteString.length); <span class="comment">// </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; byteString.length; i++) &#123;</span><br><span class="line">    ia[i] = byteString.charCodeAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([ia], &#123; <span class="attr">type</span>: mimeString &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;superagent&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">submit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> blob = dataURItoBlob(base64Data);</span><br><span class="line">  <span class="keyword">const</span> fd = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.querySelector(<span class="string">&#x27;form&#x27;</span>));</span><br><span class="line">  fd.append(fileName, blob, file.file.name);</span><br><span class="line"></span><br><span class="line">  request.post(action)</span><br><span class="line">    .send(fd)</span><br><span class="line">    .end(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// eg.成功回调的处理逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (err || !res.ok) &#123;</span><br><span class="line">        <span class="comment">// 处理 request 返回的请求错误</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;not 200 error msg:&quot;</span> + err);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理后端返回的请求错误</span></span><br><span class="line">        <span class="keyword">if</span> (res.body.errorCode === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">// do something ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// do something ...</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001399413803339f4bbda5c01fc479cbea98b1387390748000">base64 - 廖雪峰的官方网站</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Base64/" rel="tag">Base64</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FormData/" rel="tag">FormData</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-hack-ios-11-n-iphone-X" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/01/31/hack-ios-11-n-iphone-X/" class="article-date">
  	<time datetime="2018-01-30T16:00:00.000Z" itemprop="datePublished">2018-01-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/31/hack-ios-11-n-iphone-X/">iOS 11 及 iPhone X 爬坑姿势</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-序言"><a href="#1-序言" class="headerlink" title="1 序言"></a>1 序言</h2><p>2017 年 9 月 12 日凌晨，苹果在乔布斯剧院发布了 iPhone X。iPhone X 正面的全面屏上方有一条刘海，对于如何适配 iPhone X，苹果的 Human Interface Guidelines 文档有给出相关的说明，但是对于前端开发者来说，我们还应该关注到更多的东西。</p>
<p>iOS 11 新引入了若干个 Webkit API 来解决带来的适配问题，使用这些新的 API 我们可以更好的利用 iPhone X 屏幕的特性。</p>
<h2 id="2-相关概念"><a href="#2-相关概念" class="headerlink" title="2 相关概念"></a>2 相关概念</h2><p>在了解新 API 之前需要先了解苹果设备屏幕的相关概念，接下来简单的对之进行说明。</p>
<h3 id="2-1-安全区域（Safe-Area）"><a href="#2-1-安全区域（Safe-Area）" class="headerlink" title="2.1 安全区域（Safe Area）"></a>2.1 安全区域（Safe Area）</h3><p>在苹果的 <a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview/positioning_content_relative_to_the_safe_area">UIKit文档</a> 中，提到了安全区域。</p>
<p><img src="https://tvax1.sinaimg.cn/large/6f4890d4gy1gml6m61cgwj20w40m6gps.jpg" alt="safe_area_1"></p>
<p><img src="https://tva3.sinaimg.cn/large/6f4890d4gy1gml6med798j20ih093t95.jpg" alt="safe_area_2"></p>
<p>简单的说，将内容放在这样的 Safe area 可以确保内容不会被设备圆角（corners），传感器外壳（sensor housing，齐刘海）以及底部的 Home Indicator 遮挡。</p>
<h2 id="3-相关-API"><a href="#3-相关-API" class="headerlink" title="3 相关 API"></a>3 相关 API</h2><h3 id="3-1-viewport-fit"><a href="#3-1-viewport-fit" class="headerlink" title="3.1 viewport-fit"></a>3.1 viewport-fit</h3><h4 id="3-1-1-基础介绍"><a href="#3-1-1-基础介绍" class="headerlink" title="3.1.1 基础介绍"></a>3.1.1 基础介绍</h4><p>iOS 11 与早期的版本有个不同的地方，Webview 内容将会尊重所谓的安全区域。这意味着，如果你有一个标题栏固定在顶部 <code>position: fixed; top: 0</code> 。它将会在屏幕顶部下面的 20px 开始渲染。当你向下滚动时，它会移动到状态栏的后面。当你向上滚动时，它会再次下降到状态栏下面，而且在 20px 的间隙中，内容会透出。在 <a target="_blank" rel="noopener" href="https://ayogo.com/blog/ios11-viewport/">Understanding the WebView Viewport in iOS 11</a> 这篇文章中的视频可以看到实际是怎么样的。不过这个恼人的问题通过给 <code>viewport-fit</code> 进行配置即可解决。</p>
<p><code>viewport-fit</code> 可以设置可视窗口（Visual Viewport）的大小。在设备的物理屏幕上看到的初始布局视窗。在圆形屏幕上，当前屏幕上显示的部分是圆形的，但是 Viewport 却是矩形的。因此，根据 Viewport 的大小，页面的某些部可能被剪切。</p>
<p><img src="https://tva3.sinaimg.cn/large/6f4890d4gy1gml6mv2ahbj20iw0m6jto.jpg" alt="clipped_area"></p>
<p><code>viewport-fit</code> 可以设置可视视窗的大小，也就是裁剪区域，<code>viewport-fit</code> 接收以下三个值：</p>
<ul>
<li><code>contain</code>：viewport 中可以显示整个页面的内容，也就是说那些 position 设置为 fixed 的元素会相对于 iOS 11 的安全区域定位。<blockquote>
<p>注意: 设置该属性值时，<code>border-boundary: display</code> 和 <code>shape-inside: display</code> 会失效。</p>
</blockquote>
</li>
<li><code>cover</code>：页面的内容完全覆盖整个 viewport。也就是说那些 <code>position: fixed</code> 的元素会相对于 viewport 定位，这就可能导致页面中有的内容会被遮盖。</li>
<li><code>auto</code>：默认值，表现与 contain 一致。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-round-display/">CSS Round Display Level 1</a> 中有给出了一些对于这个属性的建议：</p>
<blockquote>
<p>当在非矩形显示器上设置 viewport 的边界框（viewport Bounding Box）大小时，必须考虑以下因素：</p>
</blockquote>
<blockquote>
<ul>
<li>由于 viewport 边界框（viewport Bounding Box）的面积大于显示区域，导致剪切区域</li>
</ul>
</blockquote>
<ul>
<li>在 Viewport 边界框和显示区域之间存在间隙</li>
</ul>
<blockquote>
<p>开发人员可以决定哪一个因素比较重要。如果必须确保 web 页面的没有任何一部分被隐藏，那么避免发生剪裁的优先级要高于处理在 viewport 的边界框和屏幕的边框之间的间隙。如果不想让 web 页面被缩小导致可读性上降低，那么最好将 <code>viewport-fit</code> 设置为 cover ，但是要注意页面被裁剪的部分。</p>
</blockquote>
<p>我们直接看规范中给出的例子：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@viewport</span> (<span class="attribute">viewport-fit:</span> contain) &#123;</span><br><span class="line">    <span class="comment">/* CSS for the rectangular design */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tvax4.sinaimg.cn/large/6f4890d4gy1gml6n94vc1j20ho0k1js7.jpg" alt="viewport_fit_contain"></p>
<p>当将 <code>viewport-fit</code> 设置为 contain 时，viewport 会以显示完整的、最大的矩形页面为依据，去展示 web 内容。在 iPhone X 中可视区域内多余的区域会以白色的背景色显示。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@viewport</span> &#123;</span><br><span class="line">    <span class="selector-tag">viewport-fit</span>: <span class="selector-tag">cover</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">shape:</span> round)&#123;</span><br><span class="line">    <span class="comment">/* styles for the round design */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">shape:</span> rect)&#123;</span><br><span class="line">    <span class="comment">/* styles for the rectangular design */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/6f4890d4gy1gml6nks3gdj20i80jrdhq.jpg" alt="viewport_fit_cover"></p>
<p>当将 <code>viewport-fit</code> 设置为 cover 时，初始的 viewport 会受限于非矩形的展示区域，以填满展示区域为依据进行展示。</p>
<h4 id="3-1-2-实际应用"><a href="#3-1-2-实际应用" class="headerlink" title="3.1.2 实际应用"></a>3.1.2 实际应用</h4><p>使用 <code>viewport-fit</code> 只需在 viewport 的声明中增加 <code>viewport-fit</code> 的配置即可。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, viewport-fit=cover&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过给 <code>viewport-fit</code> 设置 cover 可以页面内容充满 iPhone X 的屏幕。下面是不作处理的 iPhone X 打开页面，可以看到有两条白边。</p>
<p><img src="https://tvax3.sinaimg.cn/large/6f4890d4gy1gml6nxsic4j21hk0ua10r.jpg" alt="iphone_x_with_white_wings"></p>
<p>设置了 viewport-fit 为 cover 之后：</p>
<p><img src="https://tva1.sinaimg.cn/large/6f4890d4gy1gml6o81ogej21hk0uajzw.jpg" alt="iphone_x_with_viewport_fit_cover"></p>
<h3 id="3-2-safe-area-inset"><a href="#3-2-safe-area-inset" class="headerlink" title="3.2 safe-area-inset-*"></a>3.2 safe-area-inset-*</h3><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>新出的 iPhone X 形状不规则，其状态栏的高不再是 20px，而且在摄像头和扬声器的设置下，你的标题栏内容将会完全无法访问到。需要注意的是，这也适用于固定在屏幕底部的页脚，它将被麦克风阻塞。在一开始的关于安全区域的图中就可以看到，底部是有一定区域在 safe area 之外。</p>
<p>在上面一个小节，通过设置 <code>viewport-fit</code> 我们将页面的内容铺满了整个屏幕，但是可以看到“齐刘海”会将一部分的内容遮挡，如果我们知道屏幕边缘到 safe area 边缘的距离，那就可以通过设置 <code>padding</code> 属性来解决这个问题了。</p>
<p>在设置 <code>viewport-fit=cover</code> 之后，Web 中会新增四个常量：</p>
<ul>
<li><p><code>safe-area-inset-top</code>：可视区域顶部边缘到安全区域的距离（以CSS像素为单位）</p>
</li>
<li><p><code>safe-area-inset-right</code>：可视区域最右边到安全区域的距离（以CSS像素为单位）</p>
</li>
<li><p><code>safe-area-inset-left</code>：可视区域最左边到安全区域的距离（以CSS像素为单位）</p>
</li>
<li><p><code>safe-area-inset-bottom</code>：可视区域底部边缘到安全区域的距离（以CSS像素为单位）</p>
</li>
</ul>
<p>对应地苹果添加了一个方法，将安全区域布局指南暴露给 CSS 。他们添加类似一个CSS的变量概念，叫作 CSS constants 。通过 <code>constant()</code> 就可以获取到上面的几个常量。<br>通过给页面的容器元素增加以下的样式属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">padding</span>: <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-top</span>) <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-right</span>) <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-bottom</span>) <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-inset-left</span>);</span><br></pre></td></tr></table></figure>
<p>可以解决内容被遮挡的问题。</p>
<p><img src="https://tvax4.sinaimg.cn/large/6f4890d4gy1gml6omw539j21hk0uagtk.jpg" alt="iphone_x_with_viewport_fit_cover_constant"></p>
<p>要注意在 <a target="_blank" rel="noopener" href="https://ayogo.com/blog/ios11-viewport/">Darryl Pogue 的文章</a>中说到：</p>
<blockquote>
<p>Note: iOS 11.0 uses the constant() syntax, but future versions will only support env()!</p>
</blockquote>
<p>在 iOS 11 中仍使用 <code>constant()</code>，但是在未来的版本将会抛弃 <code>constant()</code> 改用 <code>env()</code>。对此 Darryl Pogue 给出的一个关于 header 的样式例子如下，简单做了渐进增强。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">44px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Status bar height on iOS 10 */</span></span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Status bar height on iOS 11+ */</span></span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="built_in">constant</span>(safe-area-inset-top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-max-amp-min"><a href="#3-3-max-amp-min" class="headerlink" title="3.3 max() &amp; min ()"></a>3.3 max() &amp; min ()</h3><h4 id="3-3-1-基本介绍"><a href="#3-3-1-基本介绍" class="headerlink" title="3.3.1 基本介绍"></a>3.3.1 基本介绍</h4><blockquote>
<p>max() 和 min() 未当前版本未包含的功能</p>
</blockquote>
<p>如果你在网站设计中采用了 <code>safe-area-inset-*</code>，你可能会注意到，除了安全区域插入之外，你还需要指定最小的内填充。在上面页面中，如果我们使用了 <code>constant(safe-area-inset-left)</code>，当设备旋转回垂直方向时，左边的安全插入距离变成了 0px，文本便紧贴着屏幕边缘了。</p>
<p><code>min()</code> 和 <code>max()</code> 来实现，这两个函数会在未来的 Safari 技术预览版中可用。这两个函数都接受任意数量的参数，并返回最小值或最大值。它们能用在calc()里面，或者彼此嵌套。并且这两个函数都允许使用calc（）作为参数，就像使用数字一样。</p>
<h4 id="3-3-2-实际应用"><a href="#3-3-2-实际应用" class="headerlink" title="3.3.2 实际应用"></a>3.3.2 实际应用</h4><p>在处理左右边距时使用max()：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@supports(padding: max(0px)) &#123;</span><br><span class="line">    <span class="selector-class">.post</span> &#123;</span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="built_in">max</span>(<span class="number">12px</span>, constant(safe-area-inset-left));</span><br><span class="line">        <span class="attribute">padding-right</span>: <span class="built_in">max</span>(<span class="number">12px</span>, constant(safe-area-inset-right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 <code>@support()</code> 做功能检测很必要。</p>
</blockquote>
<h3 id="3-4-theme-color"><a href="#3-4-theme-color" class="headerlink" title="3.4 theme color"></a>3.4 theme color</h3><p>iPhone X 在 portrait 模式下（竖屏）状态栏和 URL 地址栏会有一定的透明度，所以他们会显示半透明的网页背景色。</p>
<p><img src="https://tva4.sinaimg.cn/large/6f4890d4gy1gml6p3qdvxj20m80b8ah6.jpg" alt="theme_color"></p>
<p>通过声明 <code>theme-color</code> 即可：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;theme-color&quot;</span> <span class="attr">content</span>=<span class="string">&quot;#676767&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-简单的总结"><a href="#4-简单的总结" class="headerlink" title="4 简单的总结"></a>4 简单的总结</h2><p>本文提及的 API：</p>
<ul>
<li><code>viewport-fit</code>：有 <code>contain</code>、<code>cover</code> 和 <code>auto</code> 三个取值。</li>
<li><code>safe-area-inset-*</code>：与 safe area 有关的几个常量，在设置 <code>viewport-fit=cover</code> 后可以使用</li>
<li><code>max()</code> 和 <code>min()</code>：在 CSS 中便利地获取最大值和最小值</li>
</ul>
<h2 id="5-补充扩展"><a href="#5-补充扩展" class="headerlink" title="5 补充扩展"></a>5 补充扩展</h2><p>显然除了使用以上的 API 去适配 iPhone X，还会有其他情况要使用别的适配方式。</p>
<p><img src="https://tva2.sinaimg.cn/large/6f4890d4gy1gml6pgqyhqg208g0do7c3.gif" alt="sharp_outside"></p>
<p>在张鑫旭大佬的<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2017/09/css-shapes-outside-iphone-x-head/">这篇文章</a>中有讲到这种效果如何实现，可以了解一下。</p>
<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://drafts.csswg.org/css-round-display">CSS Round Display Level 1</a></li>
<li><a target="_blank" rel="noopener" href="https://ayogo.com/blog/ios11-viewport/">Understanding the WebView Viewport in iOS 11</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/uikit/uiview/positioning_content_relative_to_the_safe_area">Positioning Content Relative to the Safe Area</a></li>
<li><a target="_blank" rel="noopener" href="http://web.jobbole.com/92448/">iPhone X的缺口和CSS</a></li>
<li><a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2017/09/css-shapes-outside-iphone-x-head/">借助CSS Shapes实现元素滚动自动环绕iPhone X的刘海</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Safari/" rel="tag">Safari</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-decorator-and-its-example" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/10/decorator-and-its-example/" class="article-date">
  	<time datetime="2017-12-09T16:00:00.000Z" itemprop="datePublished">2017-12-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/10/decorator-and-its-example/">装饰器及其相关实例</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-装饰器的概念"><a href="#1-装饰器的概念" class="headerlink" title="1. 装饰器的概念"></a>1. 装饰器的概念</h2><h3 id="1-0-前言"><a href="#1-0-前言" class="headerlink" title="1-0. 前言"></a>1-0. 前言</h3><p>装饰器 (Decorator) 是 ES2017 中的一个<a target="_blank" rel="noopener" href="https://tc39.github.io/proposal-decorators/">提案</a>，装饰器的出现，给我们在多个不同类之间共享或者扩展一些方法或者行为的时候，提供了一种更加优雅的方法。</p>
<h3 id="1-1-什么是装饰器"><a href="#1-1-什么是装饰器" class="headerlink" title="1-1. 什么是装饰器"></a>1-1. 什么是装饰器</h3><p>简单的说，修饰器就是一个对类进行处理的函数，可以给类以及类的方法添加一些行为，而又不改变其代码。<br>在 Python 中，对于 装饰器 (Decorator) 是这样定义的：</p>
<blockquote>
<p>A Python decorator is a function that takes another function, extending the behavior of the latter function without explicitly modifying it.<br>Python 装饰器是接受另一个函数作为参数的函数，扩展参数函数行为的同时并没有修改参数函数本身。</p>
</blockquote>
<p>我们通过一个简单的例子来说明装饰器是什么，以下代码是一个给类添加属性 <code>isTestable</code> 的装饰器，通过 <code>@testable</code> 这样的调用，可以给类增加一个 <code>isTestable = true</code> 的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="1-2-设计模式-装饰模式"><a href="#1-2-设计模式-装饰模式" class="headerlink" title="1-2. 设计模式: 装饰模式"></a>1-2. 设计模式: 装饰模式</h3><p>装饰模式是 <em>包装模式 (Wrapper Pattern)</em> 的一种，同为包装模式的还有适配器模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。</p>
<p>装饰模式的设计模式是为了动态地给一个对象增加额外的行为，单就增加功能来说，装饰模式要比生成子类的方式更加灵活。遇到符合下面描述的情况时，可以考虑使用装饰模式：</p>
<ul>
<li>需要扩展一个类的功能，或者给一个类增加属性</li>
<li>需要动态的给一个对象增加功能，这些功能需要动态的撤销</li>
<li>需要增加一些基本功能的排列组合而产生的非常大量的功能，从而使继承变得不现实</li>
</ul>
<h2 id="2-ES6-中的装饰器"><a href="#2-ES6-中的装饰器" class="headerlink" title="2. ES6 中的装饰器"></a>2. ES6 中的装饰器</h2><p>ES6 中装饰器使用特殊的语法，使用 <code>@</code> 作为标识符，且放置在被装饰代码之前。一个类可以被多个不同的装饰器装饰，在代码进行编译的时候，按照顺序相应执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@log()</span><br><span class="line">@immutable()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  @time(<span class="string">&#x27;demo&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">doSomething</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，装饰器对于类的行为的改变，是在代码编译的时候发生的，并不是在运行时。这意味着，修饰器能在编译阶段运行代码。也就是说，修饰器本质就是编译时执行的函数。</p>
<h3 id="2-1-关于-Object-defineProperty"><a href="#2-1-关于-Object-defineProperty" class="headerlink" title="2-1. 关于 Object.defineProperty"></a>2-1. 关于 <code>Object.defineProperty</code></h3><p>ES6 中的装饰器依赖于 ES5 中的 <code>Object.defineProperty</code>，<code>Object.defineProperty</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。</p>
<p><code>Object.defineProperty</code> 的语法如下：</p>
<blockquote>
<p>Object.defineProperty(obj, prop, descriptor)</p>
</blockquote>
<p>参数 <code>obj</code> 为要在其上定义属性的对象，<code>prop</code> 为要定义或者修改的属性的名称，<code>descripor</code> 为将被定义或修改的属性描述符，对于属性描述符有哪些，可以看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">这里</a>。<br>该方法返回被传递给函数的对象。</p>
<p><code>Object.defineProperty</code>允许精确添加或修改对象的属性。通过赋值来添加的普通属性会创建在属性枚举期间显示的属性（ <code>for...in</code> 或 <code>Object.keys</code> 方法）， 这些值可以被改变，也可以被删除。这种方法允许这些额外的细节从默认值改变。默认情况下，使用 <code>Object.defineProperty()</code> 添加的属性值是不可变的。</p>
<h3 id="2-2-装饰器的使用"><a href="#2-2-装饰器的使用" class="headerlink" title="2-2. 装饰器的使用"></a>2-2. 装饰器的使用</h3><p>接下来我们通过几个简单的例子来看看，如何使用 ES6 提供的语法糖。</p>
<h4 id="2-2-1-对类的装饰器"><a href="#2-2-1-对类的装饰器" class="headerlink" title="2-2-1. 对类的装饰器"></a>2-2-1. 对类的装饰器</h4><p>像我们在 1-1 中举的例子 <code>testable</code> 就是一个对类进行装饰的例子，这个例子可以用带参数的方法实现，类似于工厂方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line">MyClass.isTestable <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyTestableClass();</span><br><span class="line">obj.isTestable <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-对类属性的装饰器"><a href="#2-2-2-对类属性的装饰器" class="headerlink" title="2-2-2. 对类属性的装饰器"></a>2-2-2. 对类属性的装饰器</h4><p>类属性装饰器适用于类的单独成员，接收三个参数：</p>
<ul>
<li><code>target</code> 被修饰的类</li>
<li><code>name</code> 要修饰的类成员的名字</li>
<li><code>descriptor</code> 要修饰的类成员的描述符</li>
</ul>
<p>可以看到接收参数与 <code>Object.defineProperty</code> 完全类似。</p>
<p>对于类属性的装饰，可以先看一个非常常见的只读实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  discriptor.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> discriptor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;meow&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wangcai = <span class="keyword">new</span> Cat();</span><br><span class="line">wangcai.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;woof&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Exception: Attempted to assign to readonly property</span></span><br></pre></td></tr></table></figure>
<p>可以看到对 <code>wangcai</code> 的 <code>say</code> 方法进行修改并没有生效，此时 <code>Cat</code> 对象的 <code>say</code> 方法是只读的，不可被赋值表达式改变。</p>
<h4 id="2-2-3-装饰器用于函数"><a href="#2-2-3-装饰器用于函数" class="headerlink" title="2-2-3. 装饰器用于函数"></a>2-2-3. 装饰器用于函数</h4><p>从上文中我们知道，实际上装饰器在代码编译时就运行了，存在函数提升，可以看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于函数提升的存在，实际执行的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter;</span><br><span class="line"><span class="keyword">var</span> add;</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们想让 <code>counter</code> 输出为 1 ,而<code>counter</code> 在最后给赋值了 0。</p>
<h2 id="3-应用实例"><a href="#3-应用实例" class="headerlink" title="3. 应用实例"></a>3. 应用实例</h2><h3 id="3-1-debounce-去抖动"><a href="#3-1-debounce-去抖动" class="headerlink" title="3-1. debounce (去抖动)"></a>3-1. debounce (去抖动)</h3><p>函数执行次数过于频繁导致性能问题的时候，debounce (去抖动) 可以节约性能提高用户体验。debounce (去抖动)的定义是：</p>
<blockquote>
<p>如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。</p>
</blockquote>
<p>去抖动通过限制函数执行次数，来提高用户体验。当调用动作 n 毫秒后，才会执行该动作，若在这 n 毫秒内又调用此动作则将重新计算执行时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// core-decorators/src/debounce.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; decorate, metaFor, internalDeprecation &#125; <span class="keyword">from</span> <span class="string">&#x27;./private/utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DEFAULT_TIMEOUT = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleDescriptor</span>(<span class="params">target, key, descriptor, [wait = DEFAULT_TIMEOUT, immediate = <span class="literal">false</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> callback = descriptor.value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">SyntaxError</span>(<span class="string">&#x27;Only functions can be debounced&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ...descriptor,</span><br><span class="line">    <span class="function"><span class="title">value</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; debounceTimeoutIds &#125; = metaFor(<span class="built_in">this</span>); <span class="comment">// 每个 debounce 使用独立的计时器</span></span><br><span class="line">      <span class="keyword">const</span> timeout = debounceTimeoutIds[key];</span><br><span class="line">      <span class="keyword">const</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">      <span class="keyword">const</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line"></span><br><span class="line">      debounceTimeoutIds[key] = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span> debounceTimeoutIds[key];</span><br><span class="line">        <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">          callback.apply(<span class="built_in">this</span>, args);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, wait);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">        callback.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  internalDeprecation(<span class="string">&#x27;@debounce is deprecated and will be removed shortly. Use @debounce from lodash-decorators.\n\n  https://www.npmjs.com/package/lodash-decorators&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> decorate(handleDescriptor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-混入-Mixin"><a href="#3-2-混入-Mixin" class="headerlink" title="3-2. 混入 (Mixin)"></a>3-2. 混入 (Mixin)</h3><p>混入 (Mixin) 所作的事情即枚举出一个或者多个对象的所有属性，然后将这些属性添加到另一个对象上去。</p>
<p>而实际上 jQuery 中的 <code>jQuery.extend</code>和 lodash 中的 <code>_.mixin</code> 通过不同的调用形式都实现了混入 (Mixin)。</p>
<p>依赖于 <code>Object.assign</code> 我们可以用装饰器的方式实现实现混入 (Mixin)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;foo&#x27;</span>) &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo() <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-3-简单的日志系统"><a href="#3-3-简单的日志系统" class="headerlink" title="3-3. 简单的日志系统"></a>3-3. 简单的日志系统</h3><p>通过在给类执行前后增加输出的处理，可以实现监控类行为的功能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> log = <span class="function">(<span class="params">type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, name, descriptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> method = descriptor.value;</span><br><span class="line">    descriptor.value =  <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.info(<span class="string">`(<span class="subst">$&#123;type&#125;</span>) 正在执行: <span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) = ?`</span>);</span><br><span class="line">      <span class="keyword">let</span> ret;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = method.apply(target, args);</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">`(<span class="subst">$&#123;type&#125;</span>) 成功 : <span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) =&gt; <span class="subst">$&#123;ret&#125;</span>`</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">`(<span class="subst">$&#123;type&#125;</span>) 失败: <span class="subst">$&#123;name&#125;</span>(<span class="subst">$&#123;args&#125;</span>) =&gt; <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IronMan</span> </span>&#123;</span><br><span class="line">  @log(<span class="string">&#x27;IronMan 自检阶段&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">check</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;检查完毕&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  @log(<span class="string">&#x27;IronMan 攻击阶段&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">attack</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;击倒敌人&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  @log(<span class="string">&#x27;IronMan 机体报错&#x27;</span>)</span><br><span class="line">  <span class="function"><span class="title">error</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;Something is wrong!&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tony = <span class="keyword">new</span> IronMan();</span><br><span class="line">tony.check();</span><br><span class="line">tony.attack();</span><br><span class="line">tony.error();</span><br><span class="line"></span><br><span class="line"><span class="comment">// (IronMan 自检阶段) 正在执行: check() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 自检阶段) 成功 : check() =&gt; 检查完毕</span></span><br><span class="line"><span class="comment">// (IronMan 攻击阶段) 正在执行: attack() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 攻击阶段) 成功 : attack() =&gt; 击倒敌人</span></span><br><span class="line"><span class="comment">// (IronMan 机体报错) 正在执行: error() = ?</span></span><br><span class="line"><span class="comment">// (IronMan 机体报错) 失败: error() =&gt; Something is wrong!</span></span><br></pre></td></tr></table></figure>
<h2 id="4-通过-Babel-使用"><a href="#4-通过-Babel-使用" class="headerlink" title="4. 通过 Babel 使用"></a>4. 通过 Babel 使用</h2><p>使用 npm 安装 babel-plugin-transform-decorators-legacy 插件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-plugin-transform-decorators-legacy --save-dev</span><br></pre></td></tr></table></figure>
<p>配置 <code>.babelrc</code> 文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;transform-decorators-legacy&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://tc39.github.io/proposal-decorators/">Decorators proposal</a></li>
<li><a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/decorator#%E7%B1%BB%E7%9A%84%E4%BF%AE%E9%A5%B0">修饰器 - ECMAScripe 6入门</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sitepoint.com/javascript-decorators-what-they-are/">JavaScript Decorators: What They Are and When to Use Them</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhshulin/article/details/38665187">设计模式——装饰模式（Decorator）</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty() - Javaecript | MDN</a></li>
<li><a target="_blank" rel="noopener" href="http://taobaofed.org/blog/2015/11/16/es7-decorator/">ES7 Decorator 装饰者模式</a></li>
<li><a target="_blank" rel="noopener" href="https://jinlong.github.io/2016/04/24/Debouncing-and-Throttling-Explained-Through-Examples/">实例解析防抖动（Debouncing）和节流阀（Throttling）</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lodash/lodash/blob/4.7.0/lodash.js">lodash/lodash.js</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jayphelps/core-decorators/blob/master/src/debounce.js">core-decorators/src/debounce.js</a></li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-deep-copy-and-shallow-copy" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/03/01/deep-copy-and-shallow-copy/" class="article-date">
  	<time datetime="2017-02-28T16:00:00.000Z" itemprop="datePublished">2017-03-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/01/deep-copy-and-shallow-copy/">简析 javascript 中的深拷贝和浅拷贝</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-深拷贝和浅拷贝的区别"><a href="#1-深拷贝和浅拷贝的区别" class="headerlink" title="1 深拷贝和浅拷贝的区别"></a>1 深拷贝和浅拷贝的区别</h1><h2 id="1-1-JavaScript-的变量类型"><a href="#1-1-JavaScript-的变量类型" class="headerlink" title="1.1 JavaScript 的变量类型"></a>1.1 JavaScript 的变量类型</h2><p>JavaScript 中的变量类型可以分为两类：</p>
<ul>
<li>基本类型</li>
<li>引用类型</li>
</ul>
<p>基本类型有5种：</p>
<blockquote>
<p>Undefined、Null、Boolean、Number 和 String</p>
</blockquote>
<p>引用类型即我们所说的对象，存放在堆内存。</p>
<blockquote>
<p>实际上引用类型保存的是一个指针，指向引用类型的值。当需要访问引用类型的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。</p>
</blockquote>
<h2 id="1-2-JavaScript-的深拷贝和浅拷贝"><a href="#1-2-JavaScript-的深拷贝和浅拷贝" class="headerlink" title="1.2 JavaScript 的深拷贝和浅拷贝"></a>1.2 JavaScript 的深拷贝和浅拷贝</h2><p>深拷贝和浅拷贝都是对于应用类型而言的，简单的说，浅拷贝只复制了引用类型的子级的属性，而浅拷贝不止复制子级的属性，还递归复制了所有层级的属性。</p>
<p>所以可以知道，如果复制的对象中有饮用对象，那么在只复制了引用的情况下，复制产生的新对象和原对象引用的是同一个栈里的值。</p>
<p><img src="https://tvax4.sinaimg.cn/large/6f4890d4gy1gml6haqz2xj20830633yc.jpg" alt="diff_copy"></p>
<p>废话不多说，直接上代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zhang = &#123;</span><br><span class="line">	name: <span class="string">&quot;san&quot;</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">&quot;male&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> zhang1 = zhang;</span><br><span class="line"><span class="built_in">console</span>.log(zhang);  <span class="comment">//Object &#123;name: &quot;san&quot;, age: 25, gender: &quot;male&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(zhang1); <span class="comment">//Object &#123;name: &quot;san&quot;, age: 25, gender: &quot;male&quot;&#125;</span></span><br><span class="line">zhang1.name = <span class="string">&quot;si&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(zhang);  <span class="comment">//Object &#123;name: &quot;si&quot;, age: 25, gender: &quot;male&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(zhang1); <span class="comment">//Object &#123;name: &quot;si&quot;, age: 25, gender: &quot;male&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<p>明明是修改的 zhang1 的 name ，连 zhang 的 name 也改变了厚，这就是浅拷贝。<br>根据定义我们来实现深拷贝：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zhang = &#123;</span><br><span class="line">	name: <span class="string">&quot;san&quot;</span>,</span><br><span class="line">    age: <span class="number">25</span>,</span><br><span class="line">    gender: <span class="string">&quot;male&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> zhang1 = &#123;</span><br><span class="line">	name: zhang.name,</span><br><span class="line">    age: zhang.age,</span><br><span class="line">    gender: zhang.gender</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(zhang);  <span class="comment">//Object &#123;name: &quot;san&quot;, age: 25, gender: &quot;male&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(zhang1); <span class="comment">//Object &#123;name: &quot;san&quot;, age: 25, gender: &quot;male&quot;&#125;</span></span><br><span class="line">zhang1.name = <span class="string">&quot;si&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(zhang);  <span class="comment">//Object &#123;name: &quot;san&quot;, age: 25, gender: &quot;male&quot;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(zhang1); <span class="comment">//Object &#123;name: &quot;si&quot;, age: 25, gender: &quot;male&quot;&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="2-浅拷贝的实现方法"><a href="#2-浅拷贝的实现方法" class="headerlink" title="2 浅拷贝的实现方法"></a>2 浅拷贝的实现方法</h1><h2 id="2-1-引用复制"><a href="#2-1-引用复制" class="headerlink" title="2.1 引用复制"></a>2.1 引用复制</h2><p>浅拷贝只复制第一层的子级属性，所以只要遍历对象的子级属性进行复制就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowClone</span>(<span class="params">copyObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> copyObj) &#123;</span><br><span class="line">    obj[i] = copyObj[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">  c: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> y = shallowClone(x);</span><br><span class="line"><span class="built_in">console</span>.log(y.b.f === x.b.f);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="2-2-Object-assign-函数"><a href="#2-2-Object-assign-函数" class="headerlink" title="2.2 Object.assign() 函数"></a>2.2 Object.assign() 函数</h2><p>ES2015中提供了 Object.assign() 函数，用于将指定对象和目标对象合并。 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">MDN</a> 上对于该函数的说明是：</p>
<blockquote>
<p>Object.assign() 方法用于将所有可枚举的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
</blockquote>
<p>因为 Object.assign() 拷贝的是属性值，加入源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: &#123;<span class="attr">c</span>:<span class="number">4</span>&#125; , <span class="attr">d</span>: &#123; <span class="attr">e</span>: &#123;<span class="attr">f</span>:<span class="number">1</span>&#125;&#125; &#125;</span><br><span class="line"><span class="keyword">let</span> g = <span class="built_in">Object</span>.assign(&#123;&#125;,a)</span><br><span class="line"><span class="built_in">console</span>.log(g.d) <span class="comment">//Object &#123; e: &#123; f: 1 &#125; &#125;</span></span><br><span class="line">g.d.e = <span class="number">32</span></span><br><span class="line"><span class="built_in">console</span>.log(g) <span class="comment">//Object &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//Object &#123; b: &#123; c: 4 &#125;, d: &#123; e: 32 &#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(h) <span class="comment">//Object &#123; b: &#123; c: 4 &#125;, d: &#123; e: &#123; f: 1 &#125; &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="3-深拷贝的实现方法"><a href="#3-深拷贝的实现方法" class="headerlink" title="3 深拷贝的实现方法"></a>3 深拷贝的实现方法</h1><h2 id="3-1-JSON-parse-和-JSON-stringify"><a href="#3-1-JSON-parse-和-JSON-stringify" class="headerlink" title="3.1 JSON.parse() 和 JSON.stringify()"></a>3.1 JSON.parse() 和 JSON.stringify()</h2><p>通过 <code>JSON.stringify()</code> 获得对象的 json 字符串，然后再通过 <code>JSON.parse()</code>将该字符串转化成实际对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> copya = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br></pre></td></tr></table></figure>
<p>不过这个方法的缺点也很明显：</p>
<ul>
<li>json 不支持 NaN ，Infinity 和精确的浮点数</li>
<li>不支持 function</li>
</ul>
<p>所以使用这个方法并不好，还考虑到这个方法的效率，虽然简单，但是一般情况下都不会用。</p>
<h2 id="3-2-通过递归解析的拷贝"><a href="#3-2-通过递归解析的拷贝" class="headerlink" title="3.2 通过递归解析的拷贝"></a>3.2 通过递归解析的拷贝</h2><p>这个方法其实就是递归地去解析对象的属性，将解析到的属性一条一条赋值给新的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">o, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = c || &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> o[i] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o[i].constructor === <span class="built_in">Array</span>) &#123; <span class="comment">//数组</span></span><br><span class="line">                c[i] = []</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//对象</span></span><br><span class="line">                c[i] = &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            deepCopy(o[i], c[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c[i] = o[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">b</span>: &#123;<span class="attr">c</span>:<span class="number">4</span>&#125; , <span class="attr">d</span>: &#123; <span class="attr">e</span>: &#123;<span class="attr">f</span>:<span class="number">1</span>&#125;&#125; &#125;</span><br><span class="line"><span class="keyword">var</span> g = deepCopy(a, &#123;&#125;);</span><br><span class="line"><span class="built_in">console</span>.dir(a.b.c); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.dir(g.b.c); <span class="comment">//4</span></span><br><span class="line">g.b.c = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.dir(a.b.c); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.dir(g.b.c); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<h1 id="3-jQuery-extend-函数的对象拷贝"><a href="#3-jQuery-extend-函数的对象拷贝" class="headerlink" title="3 jQuery.extend() 函数的对象拷贝"></a>3 jQuery.extend() 函数的对象拷贝</h1><h2 id="3-1-jQuery-extend-的基本用法"><a href="#3-1-jQuery-extend-的基本用法" class="headerlink" title="3.1 jQuery.extend() 的基本用法"></a>3.1 jQuery.extend() 的基本用法</h2><p><code>jQuery.extend()</code> 可以实现深拷贝和浅拷贝，这个函数大多情况下用来扩展 jQuery / jQuery.fn 对象的方法，<a target="_blank" rel="noopener" href="http://api.jquery.com/jQuery.extend/">jQuery官网</a>的解释是：</p>
<blockquote>
<p><strong>Description</strong>: Merge the contents of two or more objects together into the first object.</p>
</blockquote>
<p>个人翻译就是<strong>将多个对象的属性合并到第一个对象中</strong>，如果有同名的属性，则将第一个对象中的属性覆盖,规则上是靠后（右）的对象属性覆盖靠前（左）的对象属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object1 = &#123;</span><br><span class="line">  apple: <span class="number">0</span>,</span><br><span class="line">  banana: &#123; <span class="attr">weight</span>: <span class="number">52</span>, <span class="attr">price</span>: <span class="number">100</span> &#125;,</span><br><span class="line">  cherry: <span class="number">97</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> object2 = &#123;</span><br><span class="line">  banana: &#123; <span class="attr">price</span>: <span class="number">200</span> &#125;,</span><br><span class="line">  durian: <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> object3 = &#123;</span><br><span class="line">  banana: &#123; <span class="attr">price</span>: <span class="number">300</span> &#125;,</span><br><span class="line">  watermalon: <span class="number">50</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merge object2 and object3 into object1</span></span><br><span class="line">$.extend( object1, object2, object3 );</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(object1)); <span class="comment">//&#123;&quot;apple&quot;:0,&quot;banana&quot;:&#123;&quot;price&quot;:300&#125;,&quot;cherry&quot;:97,&quot;durian&quot;:100,&quot;watermalon&quot;:50&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="3-2-jQuery-extend-实现浅拷贝和深拷贝"><a href="#3-2-jQuery-extend-实现浅拷贝和深拷贝" class="headerlink" title="3.2 jQuery.extend() 实现浅拷贝和深拷贝"></a>3.2 jQuery.extend() 实现浅拷贝和深拷贝</h2><p>根据 <code>jQuery.extend()</code> 的定义，只需要将要拷贝的对象合并到一个空对象，就可以实现拷贝了。而将 <code>jQuery.extend()</code> 的第一个参数设置成 <code>true</code> ，就可设置成深拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">b</span>: &#123;<span class="attr">c</span>:<span class="number">4</span>&#125; , <span class="attr">d</span>: &#123; <span class="attr">e</span>: &#123;<span class="attr">f</span>:<span class="number">1</span>&#125;&#125; &#125;</span><br><span class="line"><span class="keyword">var</span> shallowc = $.extend(&#123;&#125;, a)</span><br><span class="line"><span class="keyword">var</span> deepc = $.extend(<span class="literal">true</span>, &#123;&#125;, a)</span><br><span class="line"><span class="built_in">console</span>.dir(obj.b.c); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.dir(shallowc.b.c); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.dir(deepc.b.c); <span class="comment">//4</span></span><br><span class="line">deepc.b.c = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">console</span>.dir(obj.b.c); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.dir(shallowc.b.c); <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.dir(deepc.b.c); <span class="comment">//5</span></span><br><span class="line">shallowc.b.c = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">console</span>.dir(obj.b.c); <span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.dir(shallowc.b.c); <span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.dir(deepc.b.c); <span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>可以看到 <code>$.extend(&#123;&#125;, a)</code> 和 <code>$.extend(true, &#123;&#125;, a)</code> 得到的对象分别就是浅拷贝和深拷贝得到的对象。<del>文末附上 <code>jQuery.extend()</code> 的源码。</del></p>
<h1 id="4-简单的总结"><a href="#4-简单的总结" class="headerlink" title="4 简单的总结"></a>4 简单的总结</h1><p>说了那么多，需要来简单的概括一下。</p>
<blockquote>
<p><strong>其实深拷贝的需求在实际开发中会出现的频次并不高，对于深拷贝，最好的方法就是抛弃需要深拷贝的代码</strong>。</p>
</blockquote>
<hr>
<p>参考资料：<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign() - JavaScript|MDN</a><br><a target="_blank" rel="noopener" href="http://api.jquery.com/jQuery.extend/">jQuery.extend() | jQuery API Documentation</a><br><a target="_blank" rel="noopener" href="https://github.com/wengjq/Blog/issues/3">javaScript中浅拷贝和深拷贝的实现</a><br><a target="_blank" rel="noopener" href="http://larry850806.github.io/2016/09/20/shallow-vs-deep-copy/">[Javascript] 關於 JS 中的淺拷貝和深拷貝 · Larry</a></p>
<p>附上 <code>$.extend()</code> 源码<del>（是不是跟楼上的递归很像）</del>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> options, name, src, copy, copyIsArray, clone,</span><br><span class="line">		target = <span class="built_in">arguments</span>[ <span class="number">0</span> ] || &#123;&#125;,</span><br><span class="line">		i = <span class="number">1</span>,</span><br><span class="line">		length = <span class="built_in">arguments</span>.length,</span><br><span class="line">		deep = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle a deep copy situation</span></span><br><span class="line">	<span class="keyword">if</span> ( <span class="keyword">typeof</span> target === <span class="string">&quot;boolean&quot;</span> ) &#123;</span><br><span class="line">		deep = target;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Skip the boolean and the target</span></span><br><span class="line">		target = <span class="built_in">arguments</span>[ i ] || &#123;&#125;;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle case when target is a string or something (possible in deep copy)</span></span><br><span class="line">	<span class="keyword">if</span> ( <span class="keyword">typeof</span> target !== <span class="string">&quot;object&quot;</span> &amp;&amp; !jQuery.isFunction( target ) ) &#123;</span><br><span class="line">		target = &#123;&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Extend jQuery itself if only one argument is passed</span></span><br><span class="line">	<span class="keyword">if</span> ( i === length ) &#123;</span><br><span class="line">		target = <span class="built_in">this</span>;</span><br><span class="line">		i--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> ( ; i &lt; length; i++ ) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Only deal with non-null/undefined values</span></span><br><span class="line">		<span class="keyword">if</span> ( ( options = <span class="built_in">arguments</span>[ i ] ) != <span class="literal">null</span> ) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Extend the base object</span></span><br><span class="line">			<span class="keyword">for</span> ( name <span class="keyword">in</span> options ) &#123;</span><br><span class="line">				src = target[ name ];</span><br><span class="line">				copy = options[ name ];</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Prevent never-ending loop</span></span><br><span class="line">				<span class="keyword">if</span> ( target === copy ) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Recurse if we&#x27;re merging plain objects or arrays</span></span><br><span class="line">				<span class="keyword">if</span> ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) ||</span><br><span class="line">					( copyIsArray = <span class="built_in">Array</span>.isArray( copy ) ) ) ) &#123;</span><br><span class="line"></span><br><span class="line">					<span class="keyword">if</span> ( copyIsArray ) &#123;</span><br><span class="line">						copyIsArray = <span class="literal">false</span>;</span><br><span class="line">						clone = src &amp;&amp; <span class="built_in">Array</span>.isArray( src ) ? src : [];</span><br><span class="line"></span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : &#123;&#125;;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// Never move original objects, clone them</span></span><br><span class="line">					target[ name ] = jQuery.extend( deep, clone, copy );</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Don&#x27;t bring in undefined values</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( copy !== <span class="literal">undefined</span> ) &#123;</span><br><span class="line">					target[ name ] = copy;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Return the modified object</span></span><br><span class="line">	<span class="keyword">return</span> target;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>








      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js%E5%AF%B9%E8%B1%A1/" rel="tag">js对象</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/" rel="tag">深拷贝</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-let-and-const-instead-of-var" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/02/16/let-and-const-instead-of-var/" class="article-date">
  	<time datetime="2017-02-15T16:00:00.000Z" itemprop="datePublished">2017-02-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/16/let-and-const-instead-of-var/">ES6中的let、const和var</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-细数-var-的种种原罪"><a href="#1-细数-var-的种种原罪" class="headerlink" title="1 细数 var 的种种原罪"></a>1 细数 var 的种种原罪</h1><h2 id="1-1-var-使用时的变量提升"><a href="#1-1-var-使用时的变量提升" class="headerlink" title="1.1 var 使用时的变量提升"></a>1.1 var 使用时的变量提升</h2><p>总所周知，JavaScript中的作用域并不是块级作用域，而是函数作用域。所谓的作用域就是可以访问到某一个变量的代码范围，那么函数作用域又是怎么样的呢？<br>简单的来说，在我们用var声明变量时，这个变量的作用域是向声明的上下两个方向同时延伸，直到到达函数边界，这个函数边界包围的代码范围就是var的作用域。<br>也因此js引擎会将每一个var声明和函数声明都提升到封闭的函数顶部，这样才可以在变量的使用前把变量先声明，这种js引擎的处理就是“<strong>变量提升（hoisting）</strong>”。<br>可以看一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">  <span class="comment">//  console.log(c);</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<p><img src="https://tvax3.sinaimg.cn/large/6f4890d4gy1gml6qefpp7j20250130mc.jpg" alt="console1"></p>
<p>变量提升固然有其必要性，但是有的情况下会出现<code>undefined</code>和<code>ReferenceError</code>，还有相同变量名时产生的错误，都让人感觉困惑难以追查问题。</p>
<h2 id="1-2-闭包的困惑"><a href="#1-2-闭包的困惑" class="headerlink" title="1.2 闭包的困惑"></a>1.2 闭包的困惑</h2><p>MDN上对于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">闭包（Closure）</a>的定义：</p>
<blockquote>
<p>闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。换句话说，这些函数可以“记忆”它被创建时候的环境</p>
</blockquote>
<p>简单的说，闭包就是指内部函数可以访问外部函数的一种机制，但外部函数并不能访问内部函数的变量。<br>以下是一段前端面试很喜欢用到的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), i);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>结果应该是立即输出<strong>一个时间点和5</strong>，而在短暂的时间间隔后同时<strong>连续5次输出同一个时间点和5</strong>（考虑到js的定时机制并不是完全准确的，这里的时间间隔应该是大约在1秒后输出）。<br>那为什么不是输出不同的时间和0到5呢？<br>因为这里其实共用了同一个变量<code>i</code>，五个超时回调同时使用一个<code>i</code>，亦即构成了闭包，就会造成在循环完成时，<code>i</code>的值被赋为5，此时所有的超时回调还没有被回调到。<br>那么应该如何去修改成输出不同的结果呢？在这里可以选择一个比较简单的修改，就是用IIFE（Immediately Invoked Function Expression:声明即刻执行的函数表达式）来解决闭包造成的问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), j);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>可以看出来其实var的这些不便，都是早期的 JavaScript 设计导致的，很多编程语言都是向后兼容的，所以这种设计上的失误无法被修复。所以在 ES6 中推出了新的变量声明关键字<strong>let</strong>，来让作用域规则更加合理。</p>
<h1 id="2-新-var：-let"><a href="#2-新-var：-let" class="headerlink" title="2 新 var： let"></a>2 新 var： let</h1><h2 id="2-1-let-和-var-的区别"><a href="#2-1-let-和-var-的区别" class="headerlink" title="2.1 let 和 var 的区别"></a>2.1 let 和 var 的区别</h2><p>MDN上对于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let">let</a>语句的定义如下：</p>
<blockquote>
<p>let 语句声明一个块级作用域的本地变量，并且可选的赋予初始值。</p>
</blockquote>
<p>用法和 var 一样，进一步的描述为：</p>
<blockquote>
<p>let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，var声明的变量只能是全局或者整个函数块的</p>
</blockquote>
<p>简单的说，let 的作用域是块，而 var 的作用域是函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a === <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">4</span>; <span class="comment">// The scope is inside the if-block</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>; <span class="comment">// The scope is inside the function</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a);  <span class="comment">// 4</span></span><br><span class="line">  <span class="built_in">console</span>.log(b);  <span class="comment">// 1</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>所以可以知道在程序或者函数的顶层，let 并不会想 var 一样在全局对象上创造一个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.x); <span class="comment">// &quot;global&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.y); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>此外还要注意一点，<strong>let 变量的重复声明是语法错误</strong>，所以如果有一些脚本声明了相同的全局变量，那么在二次加载的时候会出现报错。</p>
<blockquote>
<p>let 是一个严格模式下的保留词。在非严格模式的代码中，为了向后兼容，你仍然可以声明变量、函数和名为 let 的实参——你可以写 <code>var let = &#39;q&#39;;</code>，而不是你原本想写的那样。<code>let let;</code> 也是不允许的。</p>
</blockquote>
<h2 id="2-2-Const"><a href="#2-2-Const" class="headerlink" title="2.2 Const"></a>2.2 Const</h2><p>const 声明创建一个只读的常量。这不意味着常量指向的值不可变，而是变量标识符的值只能赋值一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">PI <span class="comment">// 3.14</span></span><br><span class="line">PI = <span class="number">3</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<p>const 的声明需要立即进行赋值，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> FOO; <span class="comment">// SyntaxError: missing = in const declaration</span></span><br></pre></td></tr></table></figure>
<p>在给一个常量定义成对象时需要注意区分这里的常量指的是这个对象的地址，因为<strong>复合类型的变量，变量名不指向数据，而是指向数据所在的地址</strong>（这里跟C里的指针十分类似）。</p>
<p>可以简单地理解成存储数据的地址是常量，这个地址是不变的，而该存储单元存储的数据是可以改变的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MY_OBJECT = &#123;<span class="string">&quot;key&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">MY_OBJECT = &#123;<span class="string">&quot;OTHER_KEY&quot;</span>: <span class="string">&quot;value&quot;</span>&#125;; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象属性并不在保护的范围内，下面这个声明会成功执行</span></span><br><span class="line">MY_OBJECT.key = <span class="string">&quot;otherValue&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>还有个关于数组的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">&#x27;Hello&#x27;</span>); <span class="comment">// [&#x27;Hello&#x27;]</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// []</span></span><br><span class="line">a = [<span class="string">&#x27;Dave&#x27;</span>];    <span class="comment">// Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>


<p>参考资料：<br><a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/es-six-deeply/let-and-const.html">let 和 const</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25855075">80% 应聘者都不及格的 JS 面试题</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let">let - JavaScript|MDN</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/" rel="tag">作用域</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-calendar-diy" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/01/21/calendar-diy/" class="article-date">
  	<time datetime="2017-01-20T16:00:00.000Z" itemprop="datePublished">2017-01-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/01/21/calendar-diy/">自制简易日历</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-日历插件的需求分析"><a href="#1-日历插件的需求分析" class="headerlink" title="1. 日历插件的需求分析"></a>1. 日历插件的需求分析</h1><p>在官网电商部分的开发中，遇到了需要自定义日历插件的情况，日历中的每一天都需要显示库存or价格，而此前使用的日历插件仅仅只有选择的功能，在这种情况下简单地研究了下日历的生成以及相关的一些兼容性问题。</p>
<p>所以经过简单的分析，简单总结：</p>
<ul>
<li>正确的日期显示以及排版</li>
<li>响应某一个日期的点击事件</li>
<li>随时对日历的月份进行修改（月份上移or下移），即重新渲染日历</li>
</ul>
<h1 id="2-实际代码编写"><a href="#2-实际代码编写" class="headerlink" title="2. 实际代码编写"></a>2. 实际代码编写</h1><h2 id="2-1-参数约定"><a href="#2-1-参数约定" class="headerlink" title="2.1 参数约定"></a>2.1 参数约定</h2><p>首先我们用一个对象来存储传入的参数，调出一个基本的当月日历，需要传入年、月份。<br>此外根据实际情况需要在每一天显示的内容，增加一个模板的参数，传入每一天所要显示的内容，传入HTML内容即可。<br>除了以上的最基本内容，我这里加入了日历的调整范围，即通过日历的上一月下一月按钮可以到达的最早的月份和最晚的月份。<br>得到的对象如下，这里我们在方法中先声明默认的值，在不传入任何参数的情况下，显示当前月份，并且将对日历月份没有任何限制。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var defaultSeeting = &#123;</span><br><span class="line">	<span class="string">&quot;year&quot;</span>: new Date().getFullYear(),//年</span><br><span class="line">    <span class="string">&quot;month&quot;</span>: new Date().getMonth() + 1,//月</span><br><span class="line">    <span class="string">&quot;template&quot;</span>: <span class="string">&quot;&#123;&#123;date&#125;&#125;&quot;</span>,//日历表格中的模板</span><br><span class="line">    <span class="string">&quot;refresh&quot;</span>: <span class="literal">false</span>//是否非页面初始化，用以控制事件的绑定</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的模板template参数使用以下的规则进行替换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @template 表格中一天的模板</span><br><span class="line"> * 模板替换规则：</span><br><span class="line"> * &#123;&#123;year&#125;&#125; -&gt; 年</span><br><span class="line"> * &#123;&#123;month&#125;&#125; -&gt; 月份</span><br><span class="line"> * &#123;&#123;date&#125;&#125; -&gt; 日期</span><br><span class="line"> * &#123;&#123;fulldate&#125;&#125; -&gt; 完整的日期</span><br><span class="line"> * &#123;&#123;day&#125;&#125; -&gt; 周几</span><br><span class="line"> * </span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<h2 id="2-2-日历的HTML渲染"><a href="#2-2-日历的HTML渲染" class="headerlink" title="2.2 日历的HTML渲染"></a>2.2 日历的HTML渲染</h2><p>我们要渲染的日历是一个<code>table</code>元素，所以本质上要处理的就是在一个<code>7*5</code>、<code>7*4</code>或者<code>7*6</code>的表格中，显示某月的每一个日期，根据表格是否属于该月来控制背景色，从单纯的展示功能来看，只要每一个<code>td</code>中显示的日期和背景颜色正确就可以了。所以我们预计效果图如下：</p>
<p><img src="https://tvax2.sinaimg.cn/large/6f4890d4gy1gml6gga5n5j20bs0dlaa7.jpg" alt="calendar_preview"></p>
<p>先考虑要拼的HTML内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;table cellpadding=<span class="string">&quot;0&quot;</span>&gt;</span><br><span class="line">	&lt;tbody&gt;</span><br><span class="line">    	&lt;tr class=<span class="string">&quot;month&quot;</span>&gt;</span><br><span class="line">        	&lt;th colspan=<span class="string">&quot;7&quot;</span>&gt;</span><br><span class="line">            	&lt;div class=<span class="string">&quot;clearfix&quot;</span>&gt;</span><br><span class="line">                	&lt;div class=<span class="string">&quot;prevMonth&quot;</span>&gt;</span><br><span class="line">                    	&lt;a class=<span class="string">&quot;prev0&quot;</span> href=<span class="string">&quot;javascript:;&quot;</span> title=<span class="string">&quot;上个月&quot;</span>&gt;上个月&lt;/a&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=<span class="string">&quot;dates&quot;</span> data-fullmonth=<span class="string">&quot;2017-2&quot;</span>&gt;</span><br><span class="line">                    	&lt;em&gt;2017&lt;/em&gt;年&lt;em&gt;2&lt;/em&gt;月</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div class=<span class="string">&quot;nextMonth&quot;</span>&gt;</span><br><span class="line">                    	&lt;a class=<span class="string">&quot;next&quot;</span> href=<span class="string">&quot;javascript:;&quot;</span> title=<span class="string">&quot;下个月&quot;</span>&gt;下个月&lt;/a&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr class=<span class="string">&quot;week&quot;</span>&gt;</span><br><span class="line">        	&lt;th class=<span class="string">&quot;weekEnd&quot;</span>&gt;&lt;span&gt;星期日&lt;/span&gt;&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;&lt;span&gt;星期一&lt;/span&gt;&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;&lt;span&gt;星期二&lt;/span&gt;&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;&lt;span&gt;星期三&lt;/span&gt;&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;&lt;span&gt;星期四&lt;/span&gt;&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;&lt;span&gt;星期五&lt;/span&gt;&lt;/th&gt;</span><br><span class="line">            &lt;th class=<span class="string">&quot;weekEnd&quot;</span>&gt;&lt;span&gt;星期六&lt;/span&gt;&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">        	&lt;td&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;p&gt;1&lt;/p&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;p&gt;2&lt;/p&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;p&gt;3&lt;/p&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;p&gt;4&lt;/p&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        //……</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<p>首先我们要获取这个月份有多少天，先以指定月份的次月1号为日期新建一个Date对象，再用这个对象的毫秒数减去一天的毫秒数（86400000）即为该月的最后一天，获取该天的日期就是我们指定的月份有多少天了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var nextMonth1st = new Date(year, month, 1),//指定月份的次月1号</span><br><span class="line">    maxdays = (new Date(Date.parse(nextMonth1st) - 86400000)).getDate();</span><br></pre></td></tr></table></figure>
<p>接下来就是日期<code>td</code>的渲染，需要判断对应的<code>td</code>是否为该月中的日期，其实只有以下的条件：</p>
<ul>
<li>小于当前月第一天的</li>
<li>大于当前月最后一天的</li>
</ul>
<p>对于日历来说，其实类似于一个二维的数组结构，所以我们只需要两层遍历去生成日历模板。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var j = 1; j &lt;= 6; j++) &#123;</span><br><span class="line">  //...</span><br><span class="line">  <span class="keyword">for</span> (var k = 1; k &lt;= 7; k++) &#123;</span><br><span class="line">    //...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在判断的条件中我们用一个变量来存储当前处于星期几，即</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var i1 = (new Date(y, m - 1 + i)).getDate(), i2 = 1；</span><br><span class="line"><span class="keyword">for</span> (var j = 1; j &lt;= 6; j++) &#123;</span><br><span class="line">  //...</span><br><span class="line">  <span class="keyword">for</span> (var k = 1; k &lt;= 7; k++) &#123;</span><br><span class="line">    i2 = (j - 1) * 7 + k -i1;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>// 断更待续</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85/" rel="tag">组件封装</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-intro-about-pushstate" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/31/intro-about-pushstate/" class="article-date">
  	<time datetime="2016-07-30T16:00:00.000Z" itemprop="datePublished">2016-07-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/31/intro-about-pushstate/">window.history.pushState引发的血案</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-pushState是什么？"><a href="#1-pushState是什么？" class="headerlink" title="1. pushState是什么？"></a>1. pushState是什么？</h1><p>这两天在实习中，要将官网的后台系统扩展，其中的一个点就是将页面的主体内容用iframe来引用，在被iframe的高度坑过一遍之后，一个问题又浮现在我的脑海中：</p>
<blockquote>
<p>使用iframe时，如果用户点击了浏览器的后退按钮，因为使用的是iframe，那么这时候整个页面都会后退，而不是用户所预料的只是iframe中页面的后退。</p>
</blockquote>
<p>针对于这个问题，首先想到的就是H5的新方法<code>history.pushState()</code>、<code>history.replaceState()</code>和<code>window.onpopstate</code>事件，但是当时由于在忙别的，所以在这个问题没有细想。</p>
<p>简单的说，history对象下的pushState是H5提出的一个新方法，可以将浏览器窗口的URL修改为自己想要的路径，并且将这个路径push到当前页面的页面浏览历史中。</p>
<p>要注意的是，这种URL的修改不会让页面刷新，亦即<strong>不会让页面发生跳转</strong>！</p>
<h5 id="1-1-history-pushState-state-title-url"><a href="#1-1-history-pushState-state-title-url" class="headerlink" title="1.1 history.pushState(state, title, url);"></a>1.1 history.pushState(state, title, url);</h5><p><code>pushState</code>的参数一共有三个:</p>
<ul>
<li><code>state</code>：可以是一个null，也可以是一个完整的对象，用来表示要push的url对应的状态信息。</li>
<li><code>title</code>：字符串，声明要push的url对象的title，实际使用时并没有什么鸟用。</li>
<li><code>url&#39;</code>：要push的history栈里的url，同时也是显示在浏览器地址栏中的地址。要注意该url<strong>不能跨域</strong>。</li>
</ul>
<p>根据该方法传入的state，我们可以通过控制台输出<code>history</code>查看其<code>state</code>，如果该url不是通过<code>pushState</code>或<code>replaceState</code>产生的，那么<code>history.state</code>就是一个null。<del>当然，如果你在pushState时传的state本来就是null，那么当我没说吼</del>。</p>
<p>在Chrome控制台测试该接口，可以看到调用了<code>pushState</code>方法之后，<code>history</code>的<code>length</code>增加了1，即将指定的url添加到了<code>history</code>栈中。</p>
<p><img src="https://tvax2.sinaimg.cn/large/6f4890d4gy1gml6pu9y1sj20c403edfw.jpg" alt="pushState"></p>
<h5 id="1-2-history-replaceState（state-title-url"><a href="#1-2-history-replaceState（state-title-url" class="headerlink" title="1.2 history.replaceState（state, title, url)"></a>1.2 history.replaceState（state, title, url)</h5><p><code>replaceState</code>的参数与pushState的参数一致。</p>
<p>调用了<code>replaceState</code>方法之后，<code>history</code>的<code>length</code>不变，指定的url没有被添加到<code>history</code>栈中，仅仅只是浏览器地址栏的url改变。</p>
<p><img src="https://tvax3.sinaimg.cn/large/6f4890d4gy1gml6q2vdz9j20cg038dfw.jpg" alt="replaceState"></p>
<h1 id="2-window-onpopstate"><a href="#2-window-onpopstate" class="headerlink" title="2 window.onpopstate"></a>2 window.onpopstate</h1><p><code>window</code>下的<code>popstate</code>事件是在<code>history</code>发生变化时触发，也就是说调用<code>history.go()</code>和<code>history.back()</code>都会触发该事件。<br>但是要注意，我们上面提到的<code>history.pushState()</code>和<code>history.replaceState()</code>并不会触发该事件。</p>
<h1 id="3-仓促结尾的说明"><a href="#3-仓促结尾的说明" class="headerlink" title="3 仓促结尾的说明"></a>3 仓促结尾的说明</h1><p>本来想延伸开来讲一下API的具体应用，但是由于种种原因，在这里就只是简单介绍API的使用方法，具体应用的话等到以后有机会再来介绍（<del>其实就是还没有在生产环节用过…XD</del>）。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2021 Sinker
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>


<script src="/js/main.js"></script>







<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>